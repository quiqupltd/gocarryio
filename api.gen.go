// Package gocarryio provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gocarryio

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	Oauth2Scopes     = "oauth2.Scopes"
)

// Defines values for AttributeRequestAttributeEntityType.
const (
	AttributeRequestAttributeEntityTypeADDRESS  AttributeRequestAttributeEntityType = "ADDRESS"
	AttributeRequestAttributeEntityTypePRODUCT  AttributeRequestAttributeEntityType = "PRODUCT"
	AttributeRequestAttributeEntityTypeSHIPMENT AttributeRequestAttributeEntityType = "SHIPMENT"
)

// Defines values for AttributeRequestAttributeType.
const (
	AttributeRequestAttributeTypeBOOLEAN AttributeRequestAttributeType = "BOOLEAN"
	AttributeRequestAttributeTypeENUM    AttributeRequestAttributeType = "ENUM"
	AttributeRequestAttributeTypeMAP     AttributeRequestAttributeType = "MAP"
	AttributeRequestAttributeTypeNUMBER  AttributeRequestAttributeType = "NUMBER"
	AttributeRequestAttributeTypeSTRING  AttributeRequestAttributeType = "STRING"
)

// Defines values for AttributeResponseAttributeEntityType.
const (
	AttributeResponseAttributeEntityTypeADDRESS  AttributeResponseAttributeEntityType = "ADDRESS"
	AttributeResponseAttributeEntityTypePRODUCT  AttributeResponseAttributeEntityType = "PRODUCT"
	AttributeResponseAttributeEntityTypeSHIPMENT AttributeResponseAttributeEntityType = "SHIPMENT"
)

// Defines values for AttributeResponseAttributeType.
const (
	AttributeResponseAttributeTypeBOOLEAN AttributeResponseAttributeType = "BOOLEAN"
	AttributeResponseAttributeTypeENUM    AttributeResponseAttributeType = "ENUM"
	AttributeResponseAttributeTypeMAP     AttributeResponseAttributeType = "MAP"
	AttributeResponseAttributeTypeNUMBER  AttributeResponseAttributeType = "NUMBER"
	AttributeResponseAttributeTypeSTRING  AttributeResponseAttributeType = "STRING"
)

// Defines values for AutomationRuleRequestCarrierChoice.
const (
	AutomationRuleRequestCarrierChoiceCHEAPESTCARRIER AutomationRuleRequestCarrierChoice = "CHEAPEST_CARRIER"
)

// Defines values for AutomationRuleResponseCarrierChoice.
const (
	AutomationRuleResponseCarrierChoiceCHEAPESTCARRIER AutomationRuleResponseCarrierChoice = "CHEAPEST_CARRIER"
)

// Defines values for CarriyoResponseStatus.
const (
	AwaitingCustomerCollection CarriyoResponseStatus = "awaiting_customer_collection"
	Booked                     CarriyoResponseStatus = "booked"
	Cancelled                  CarriyoResponseStatus = "cancelled"
	CancelledByCarrier         CarriyoResponseStatus = "cancelled_by_carrier"
	Delayed                    CarriyoResponseStatus = "delayed"
	Delivered                  CarriyoResponseStatus = "delivered"
	DeliveryConfirmed          CarriyoResponseStatus = "delivery_confirmed"
	Error                      CarriyoResponseStatus = "error"
	FailedCollectionAttempt    CarriyoResponseStatus = "failed_collection_attempt"
	FailedDeliveryAttempt      CarriyoResponseStatus = "failed_delivery_attempt"
	InTransit                  CarriyoResponseStatus = "in_transit"
	Missing                    CarriyoResponseStatus = "missing"
	OutForDelivery             CarriyoResponseStatus = "out_for_delivery"
	Pending                    CarriyoResponseStatus = "pending"
	ReadyForReturn             CarriyoResponseStatus = "ready_for_return"
	ReadyToShip                CarriyoResponseStatus = "ready-to-ship"
	ReturnConfirmed            CarriyoResponseStatus = "return_confirmed"
	ReturnInTransit            CarriyoResponseStatus = "return_in_transit"
	Returned                   CarriyoResponseStatus = "returned"
	Shipped                    CarriyoResponseStatus = "shipped"
	Suspended                  CarriyoResponseStatus = "suspended"
)

// Defines values for CustomAttributesConditionFieldOperator.
const (
	CustomAttributesConditionFieldOperatorEXCLUSION CustomAttributesConditionFieldOperator = "EXCLUSION"
	CustomAttributesConditionFieldOperatorINCLUSION CustomAttributesConditionFieldOperator = "INCLUSION"
)

// Defines values for CustomAttributesConditionFieldValueOperation.
const (
	CONTAINS CustomAttributesConditionFieldValueOperation = "CONTAINS"
)

// Defines values for DimensionUnit.
const (
	Cm DimensionUnit = "cm"
)

// Defines values for FreeFormRequestType.
const (
	FreeFormRequestTypeBusiness    FreeFormRequestType = "business"
	FreeFormRequestTypeResidential FreeFormRequestType = "residential"
)

// Defines values for GeographyConditionFieldOperator.
const (
	GeographyConditionFieldOperatorEXCLUSION GeographyConditionFieldOperator = "EXCLUSION"
	GeographyConditionFieldOperatorINCLUSION GeographyConditionFieldOperator = "INCLUSION"
)

// Defines values for ItemObjectWeightUnit.
const (
	ItemObjectWeightUnitKg ItemObjectWeightUnit = "kg"
)

// Defines values for ItemRequestBatteryMaterialType.
const (
	LithiumIon   ItemRequestBatteryMaterialType = "lithium_ion"
	LithiumMetal ItemRequestBatteryMaterialType = "lithium_metal"
)

// Defines values for ItemRequestBatteryPackingType.
const (
	ContainedInEquipment ItemRequestBatteryPackingType = "contained_in_equipment"
	PackedWithEquipment  ItemRequestBatteryPackingType = "packed_with_equipment"
)

// Defines values for ItemRequestWeightUnit.
const (
	ItemRequestWeightUnitKg ItemRequestWeightUnit = "kg"
)

// Defines values for LocationObjectType.
const (
	LocationObjectTypeBusiness    LocationObjectType = "business"
	LocationObjectTypeResidential LocationObjectType = "residential"
)

// Defines values for PaymentObjectPaymentMode.
const (
	PaymentObjectPaymentModeCASHONDELIVERY PaymentObjectPaymentMode = "CASH_ON_DELIVERY"
	PaymentObjectPaymentModePREPAID        PaymentObjectPaymentMode = "PRE_PAID"
)

// Defines values for PaymentRequestPaymentMode.
const (
	PaymentRequestPaymentModeCASHONDELIVERY PaymentRequestPaymentMode = "CASH_ON_DELIVERY"
	PaymentRequestPaymentModePREPAID        PaymentRequestPaymentMode = "PRE_PAID"
)

// Defines values for RulesetRequestEntityType.
const (
	RulesetRequestEntityTypeFORWARD RulesetRequestEntityType = "FORWARD"
	RulesetRequestEntityTypeREVERSE RulesetRequestEntityType = "REVERSE"
)

// Defines values for RulesetResponseEntityType.
const (
	RulesetResponseEntityTypeFORWARD RulesetResponseEntityType = "FORWARD"
	RulesetResponseEntityTypeREVERSE RulesetResponseEntityType = "REVERSE"
)

// Defines values for ServiceLevelRuleRequestConfigType.
const (
	ServiceLevelRuleRequestConfigTypeDELIVERY    ServiceLevelRuleRequestConfigType = "DELIVERY"
	ServiceLevelRuleRequestConfigTypeFULFILLMENT ServiceLevelRuleRequestConfigType = "FULFILLMENT"
	ServiceLevelRuleRequestConfigTypePROMISED    ServiceLevelRuleRequestConfigType = "PROMISED"
	ServiceLevelRuleRequestConfigTypeSHIPPING    ServiceLevelRuleRequestConfigType = "SHIPPING"
)

// Defines values for ServiceLevelRuleResponseConfigType.
const (
	ServiceLevelRuleResponseConfigTypeDELIVERY    ServiceLevelRuleResponseConfigType = "DELIVERY"
	ServiceLevelRuleResponseConfigTypeFULFILLMENT ServiceLevelRuleResponseConfigType = "FULFILLMENT"
	ServiceLevelRuleResponseConfigTypePROMISED    ServiceLevelRuleResponseConfigType = "PROMISED"
	ServiceLevelRuleResponseConfigTypeSHIPPING    ServiceLevelRuleResponseConfigType = "SHIPPING"
)

// Defines values for ShipmentDraftRequestEntityType.
const (
	ShipmentDraftRequestEntityTypeFORWARD ShipmentDraftRequestEntityType = "FORWARD"
	ShipmentDraftRequestEntityTypeREVERSE ShipmentDraftRequestEntityType = "REVERSE"
)

// Defines values for ShipmentObjectEntityType.
const (
	ShipmentObjectEntityTypeFORWARD ShipmentObjectEntityType = "FORWARD"
	ShipmentObjectEntityTypeREVERSE ShipmentObjectEntityType = "REVERSE"
)

// Defines values for ShipmentRequestEntityType.
const (
	ShipmentRequestEntityTypeFORWARD ShipmentRequestEntityType = "FORWARD"
	ShipmentRequestEntityTypeREVERSE ShipmentRequestEntityType = "REVERSE"
)

// Defines values for ShippingRateItemRequestWeightUnit.
const (
	ShippingRateItemRequestWeightUnitKg ShippingRateItemRequestWeightUnit = "kg"
)

// Defines values for ShippingRatesRequestEntityType.
const (
	ShippingRatesRequestEntityTypeFORWARD ShippingRatesRequestEntityType = "FORWARD"
	ShippingRatesRequestEntityTypeREVERSE ShippingRatesRequestEntityType = "REVERSE"
)

// Defines values for StatusField.
const (
	ACTIVE   StatusField = "ACTIVE"
	DELETED  StatusField = "DELETED"
	INACTIVE StatusField = "INACTIVE"
)

// Defines values for StringConditionFieldOperator.
const (
	EXCLUSION StringConditionFieldOperator = "EXCLUSION"
	INCLUSION StringConditionFieldOperator = "INCLUSION"
)

// Defines values for WeightUnit.
const (
	WeightUnitKg WeightUnit = "kg"
)

// Defines values for ListCarrierAccountsParamsStatus.
const (
	Active   ListCarrierAccountsParamsStatus = "active"
	Deleted  ListCarrierAccountsParamsStatus = "deleted"
	Inactive ListCarrierAccountsParamsStatus = "inactive"
)

// AttributeRequest defines model for attribute-request.
type AttributeRequest struct {
	AllowedValues       []string                             `json:"allowed_values"`
	AttributeEntityType *AttributeRequestAttributeEntityType `json:"attribute_entity_type,omitempty"`
	AttributeName       string                               `json:"attribute_name"`
	AttributeType       AttributeRequestAttributeType        `json:"attribute_type"`
	Merchants           *[]string                            `json:"merchants,omitempty"`
}

// AttributeRequestAttributeEntityType defines model for AttributeRequest.AttributeEntityType.
type AttributeRequestAttributeEntityType string

// AttributeRequestAttributeType defines model for AttributeRequest.AttributeType.
type AttributeRequestAttributeType string

// AttributeResponse defines model for attribute-response.
type AttributeResponse struct {
	AllowedValues       []string                              `json:"allowed_values"`
	AttributeEntityType *AttributeResponseAttributeEntityType `json:"attribute_entity_type,omitempty"`
	AttributeName       string                                `json:"attribute_name"`
	AttributeType       AttributeResponseAttributeType        `json:"attribute_type"`
	CustomAttributeId   *string                               `json:"custom_attribute_id,omitempty"`
	Merchants           *[]string                             `json:"merchants,omitempty"`
}

// AttributeResponseAttributeEntityType defines model for AttributeResponse.AttributeEntityType.
type AttributeResponseAttributeEntityType string

// AttributeResponseAttributeType defines model for AttributeResponse.AttributeType.
type AttributeResponseAttributeType string

// AutomationRuleRequest defines model for automation-rule-request.
type AutomationRuleRequest struct {
	// CarrierAccounts Carrier accounts result
	CarrierAccounts []struct {
		CarrierAccountId *string `json:"carrier_account_id,omitempty"`
	} `json:"carrier_accounts"`

	// CarrierChoice Mandatory if 'carrier_accounts' contains more than 1 entry. Used to select the best carrier
	CarrierChoice *AutomationRuleRequestCarrierChoice `json:"carrier_choice,omitempty"`

	// ChargeableWeight shipment.parcels chargeable (gross or volumetric which higher) weight is inside range
	ChargeableWeight *NumberAreaConditionField `json:"chargeable_weight,omitempty"`

	// CustomConditions shipment.custom_attributes matches condition
	CustomConditions *CustomAttributesConditionField `json:"custom_conditions,omitempty"`

	// CustomerAddressVerified Customer is verified or not
	CustomerAddressVerified *bool `json:"customer_address_verified,omitempty"`

	// DangerousGoods shipment.[items].dangerous_goods is any item matches
	DangerousGoods *bool `json:"dangerous_goods,omitempty"`

	// Days Days when rule applies
	Days *DaysField `json:"days,omitempty"`

	// DeliveryType shipment.delivery.delivery_type matches condition
	DeliveryType *StringConditionField `json:"delivery_type,omitempty"`
	Description  *string               `json:"description,omitempty"`

	// DropoffPartnerLocationIds shipment.dropoff.partner_location_id matches condition
	DropoffPartnerLocationIds *StringConditionField `json:"dropoff_partner_location_ids,omitempty"`

	// DropoffV2 shipment.dropoff country state city area condition
	DropoffV2 *GeographyConditionField `json:"dropoff_v2,omitempty"`

	// EndTime Time range when rule applies
	EndTime *float32 `json:"end_time,omitempty"`

	// GrossWeight shipment.parcels gross weight is inside range
	GrossWeight *NumberAreaConditionField `json:"gross_weight,omitempty"`

	// Merchant shipment.merchant matches condition
	Merchant *StringConditionField `json:"merchant,omitempty"`

	// OrderType shipment.order_type matches condition
	OrderType *StringConditionField `json:"order_type,omitempty"`

	// OrderValueMax shipment.payment.total_amount not more. Use -1 value for infinite
	OrderValueMax float32 `json:"order_value_max"`

	// OrderValueMin shipment.payment.total_amount not less. Use -1 value for infinite
	OrderValueMin float32 `json:"order_value_min"`

	// ParcelCount shipment.parcels items count is inside range
	ParcelCount *NumberAreaConditionField `json:"parcel_count,omitempty"`

	// PaymentType shipment.payment.payment_type matches condition
	PaymentType *StringConditionField `json:"payment_type,omitempty"`

	// PickupPartnerLocationIds shipment.pickup.partner_location_id matches condition
	PickupPartnerLocationIds *StringConditionField `json:"pickup_partner_location_ids,omitempty"`

	// PickupV2 shipment.pickup country state city area condition
	PickupV2 *GeographyConditionField `json:"pickup_v2,omitempty"`
	RuleName string                   `json:"rule_name"`

	// Sequence Sequence number used for rules prioritisation (lower is more important)
	Sequence float32 `json:"sequence"`

	// SourceType shipment.source.source_type matches condition
	SourceType *StringConditionField `json:"source_type,omitempty"`

	// StartTime Time range when rule applies
	StartTime *float32    `json:"start_time,omitempty"`
	Status    StatusField `json:"status"`

	// VolumetricWeight shipment.parcels volumetric weight is inside range
	VolumetricWeight *NumberAreaConditionField `json:"volumetric_weight,omitempty"`
}

// AutomationRuleRequestCarrierChoice Mandatory if 'carrier_accounts' contains more than 1 entry. Used to select the best carrier
type AutomationRuleRequestCarrierChoice string

// AutomationRuleResponse defines model for automation-rule-response.
type AutomationRuleResponse struct {
	CarrierAccounts *[]struct {
		CarrierAccountId *string `json:"carrier_account_id,omitempty"`
	} `json:"carrier_accounts,omitempty"`
	CarrierChoice             *AutomationRuleResponseCarrierChoice `json:"carrier_choice,omitempty"`
	ChargeableWeight          *NumberAreaConditionField            `json:"chargeable_weight,omitempty"`
	CreationDate              *time.Time                           `json:"creation_date,omitempty"`
	CustomConditions          *CustomAttributesConditionField      `json:"custom_conditions,omitempty"`
	CustomerAddressVerified   *bool                                `json:"customer_address_verified,omitempty"`
	DangerousGoods            *bool                                `json:"dangerous_goods,omitempty"`
	Days                      *DaysField                           `json:"days,omitempty"`
	DeliveryType              *StringConditionField                `json:"delivery_type,omitempty"`
	Description               *string                              `json:"description,omitempty"`
	DropoffPartnerLocationIds *StringConditionField                `json:"dropoff_partner_location_ids,omitempty"`
	DropoffV2                 *GeographyConditionField             `json:"dropoff_v2,omitempty"`
	EndTime                   *float32                             `json:"end_time,omitempty"`
	GrossWeight               *NumberAreaConditionField            `json:"gross_weight,omitempty"`
	Merchant                  *StringConditionField                `json:"merchant,omitempty"`
	OrderType                 *StringConditionField                `json:"order_type,omitempty"`
	OrderValueMax             *float32                             `json:"order_value_max,omitempty"`
	OrderValueMin             *float32                             `json:"order_value_min,omitempty"`
	ParcelCount               *NumberAreaConditionField            `json:"parcel_count,omitempty"`
	PaymentType               *StringConditionField                `json:"payment_type,omitempty"`
	PickupPartnerLocationIds  *StringConditionField                `json:"pickup_partner_location_ids,omitempty"`
	PickupV2                  *GeographyConditionField             `json:"pickup_v2,omitempty"`
	RuleId                    *string                              `json:"rule_id,omitempty"`
	RuleName                  *string                              `json:"rule_name,omitempty"`
	RuleSetId                 *string                              `json:"rule_set_id,omitempty"`
	Sequence                  *float32                             `json:"sequence,omitempty"`
	SourceType                *StringConditionField                `json:"source_type,omitempty"`
	StartTime                 *float32                             `json:"start_time,omitempty"`
	Status                    *StatusField                         `json:"status,omitempty"`
	Tenant                    *string                              `json:"tenant,omitempty"`
	UpdateDate                *time.Time                           `json:"update_date,omitempty"`
	VolumetricWeight          *NumberAreaConditionField            `json:"volumetric_weight,omitempty"`
}

// AutomationRuleResponseCarrierChoice defines model for AutomationRuleResponse.CarrierChoice.
type AutomationRuleResponseCarrierChoice string

// AutomationRulesetWithRulesRequest defines model for automation-ruleset-with-rules-request.
type AutomationRulesetWithRulesRequest struct {
	AutomationRuleSet RulesetRequest           `json:"automation_rule_set"`
	AutomationRules   *[]AutomationRuleRequest `json:"automation_rules,omitempty"`
}

// AutomationRulesetWithRulesResponse defines model for automation-ruleset-with-rules-response.
type AutomationRulesetWithRulesResponse struct {
	AutomationRuleSet RulesetResponse           `json:"automation_rule_set"`
	AutomationRules   *[]AutomationRuleResponse `json:"automation_rules,omitempty"`
}

// BreakdownObject The estimated cost of the shipping based either on the costing profile you have configured for the carrier or carrier costing API response
type BreakdownObject struct {
	Amount      *float32 `json:"amount,omitempty"`
	Currency    *string  `json:"currency,omitempty"`
	Description *string  `json:"description,omitempty"`
}

// BulkShipmentStatusResponse defines model for bulk-shipment-status-response.
type BulkShipmentStatusResponse struct {
	// Milestones The list of all shipment statuses
	Milestones *[]struct {
		Date   *string                `json:"date,omitempty"`
		Status *CarriyoResponseStatus `json:"status,omitempty"`
	} `json:"milestones,omitempty"`
	ShipmentId *string                `json:"shipmentId,omitempty"`
	Status     *CarriyoResponseStatus `json:"status,omitempty"`
}

// CarrierAccountEndpointObject defines model for carrier-account-endpoint-object.
type CarrierAccountEndpointObject struct {
	AutoReadyToShip        *bool   `json:"auto_ready_to_ship,omitempty"`
	AutoReturnConfirmed    *bool   `json:"auto_return_confirmed,omitempty"`
	AutoTranslateToEnglish *bool   `json:"auto_translate_to_english,omitempty"`
	Carrier                *string `json:"carrier,omitempty"`
	CarrierAccountId       *string `json:"carrier_account_id,omitempty"`
	CarrierAccountName     *string `json:"carrier_account_name,omitempty"`
	CostingProfileId       *string `json:"costing_profile_id,omitempty"`
	DailyCapacityId        *string `json:"daily_capacity_id,omitempty"`
	Deleted                *bool   `json:"deleted,omitempty"`
	InFlightCapacityId     *string `json:"in_flight_capacity_id,omitempty"`
	Label                  *struct {
		DefaultLabel *string `json:"default_label,omitempty"`
	} `json:"label,omitempty"`
	NetworkId  *string                 `json:"network_id,omitempty"`
	Property   *map[string]interface{} `json:"property,omitempty"`
	UpdateDate *string                 `json:"update_date,omitempty"`
}

// CarrierAccountEndpointRequest defines model for carrier-account-endpoint-request.
type CarrierAccountEndpointRequest struct {
	AutoReadyToShip        *bool   `json:"auto_ready_to_ship,omitempty"`
	AutoReturnConfirmed    *bool   `json:"auto_return_confirmed,omitempty"`
	AutoTranslateToEnglish *bool   `json:"auto_translate_to_english,omitempty"`
	Carrier                *string `json:"carrier,omitempty"`
	CarrierAccountId       *string `json:"carrier_account_id,omitempty"`
	CarrierAccountName     *string `json:"carrier_account_name,omitempty"`
	CostingProfileId       *string `json:"costing_profile_id,omitempty"`
	DailyCapacityId        *string `json:"daily_capacity_id,omitempty"`
	InFlightCapacityId     *string `json:"in_flight_capacity_id,omitempty"`
	Label                  *struct {
		DefaultLabel *string `json:"default_label,omitempty"`
	} `json:"label,omitempty"`
	NetworkId *string                 `json:"network_id,omitempty"`
	Property  *map[string]interface{} `json:"property,omitempty"`
}

// CarrierAccountObject Carrier account chosen for the shipment.
type CarrierAccountObject struct {
	// Carrier The actual carrier based on the carrier account assigned to the shipment
	Carrier *string `json:"carrier,omitempty"`

	// CarrierAccountName The name of the carrier account assigned to the shipment
	CarrierAccountName *string `json:"carrier_account_name,omitempty"`

	// CarrierId The id of the carrier account assigned to the shipment
	CarrierId *string `json:"carrier_id,omitempty"`
}

// CarrierAccountRequest Carrier account chosen for the shipment. Should contain either the carrier account id or carrier account name. Carrier account id takes precedence if both fields are passed.
type CarrierAccountRequest struct {
	// CarrierAccountName The name of the carrier account assigned to the shipment
	CarrierAccountName *string `json:"carrier_account_name,omitempty"`

	// CarrierId The ID of the carrier account assigned to the shipment
	CarrierId *string `json:"carrier_id,omitempty"`
}

// CarriyoResponseStatus defines model for carriyo-response-status.
type CarriyoResponseStatus string

// CollectionObject Collection details chosen for the shipment, such as scheduled collection date.
type CollectionObject struct {
	// ScheduledDate Scheduled date for collection provided by the merchant, represented using only the date part of the ISO 8601 format.
	ScheduledDate *openapi_types.Date `json:"scheduled_date,omitempty"`

	// ScheduledFrom Start datetime for collection provided by the merchant, represented using both the date and time the ISO 8601 format.
	ScheduledFrom *time.Time `json:"scheduled_from,omitempty"`

	// ScheduledTo End datetime for collection provided by the merchant, represented using both the date and time the ISO 8601 format.
	ScheduledTo *time.Time `json:"scheduled_to,omitempty"`
}

// CollectionRequest Collection details chosen for the shipment, such as scheduled collection date.
//
// # It can be set using one of the following options
//
// Option 1: Provide the `scheduled_from` and `scheduled_to` to choose the scheduled date along with start and end time.
//
// Example:
//
//	"collection": {
//	  "scheduled_from": "2022-01-01'T'10:00:00.000+1:00",
//	  "scheduled_to": "2022-01-01'T'12:00:00.000+1:00"
//	}
//
// Option 2: Provide the `scheduled_date` only to choose the entire day.
//
// Example:
//
//	"collection": {
//	  "scheduled_date": "2022-01-01"
//	}
type CollectionRequest struct {
	// ScheduledDate Scheduled date for delivery provided by the merchant, represented using only the date part of the ISO 8601 format.
	ScheduledDate *openapi_types.Date `json:"scheduled_date,omitempty"`

	// ScheduledFrom Start datetime for delivery provided by the merchant, represented using both the date and time the ISO 8601 format.
	ScheduledFrom *time.Time `json:"scheduled_from,omitempty"`

	// ScheduledTo End datetime for delivery provided by the merchant, represented using both the date and time the ISO 8601 format.
	ScheduledTo *time.Time `json:"scheduled_to,omitempty"`
}

// CreateShipmentErrorResponse The error response returned when a shipment creation request is rejected by Carriyo
type CreateShipmentErrorResponse struct {
	// Errors Array of validation errors
	Errors *[]string `json:"errors,omitempty"`

	// Status The error status
	Status *string `json:"status,omitempty"`

	// Timestamp date in format:
	// <code>yyyy-MM-dd'T'HH:mm:ss.SSSXXX</code>
	Timestamp *string `json:"timestamp,omitempty"`
}

// CustomAttributes Custom attributes in the form of a map:
// ```
// {"attribute1" : ["value1", "value2"], "attribute2" : ["value1", "value2"]}
// ```
// Please Note: You can only use custom attributes if you are subscribed to this feature.
type CustomAttributes map[string][]string

// CustomAttributesConditionField defines model for custom-attributes-condition-field.
type CustomAttributesConditionField struct {
	Operator *CustomAttributesConditionFieldOperator `json:"operator,omitempty"`
	Value    *[]struct {
		AttributeName *string                                       `json:"attribute_name,omitempty"`
		Operation     *CustomAttributesConditionFieldValueOperation `json:"operation,omitempty"`
		Values        *[]string                                     `json:"values,omitempty"`
	} `json:"value,omitempty"`
}

// CustomAttributesConditionFieldOperator defines model for CustomAttributesConditionField.Operator.
type CustomAttributesConditionFieldOperator string

// CustomAttributesConditionFieldValueOperation defines model for CustomAttributesConditionField.Value.Operation.
type CustomAttributesConditionFieldValueOperation string

// CustomFields Custom address fields in the form of a map:
// ```
// {"field1" : ["value1", "value2"], "field2" : ["value1", "value2"]}
// ```
type CustomFields map[string][]string

// CustomsObject Customs declaration details such as total declared value.
type CustomsObject struct {
	// DeclaredValue The total value of the shipment (optional) to declare for customs. This value is computed from individual item price if this is not passed.
	DeclaredValue *struct {
		Amount *float32 `json:"amount,omitempty"`

		// Currency The three-letter currency code (ISO 4217) for the amount. e.g., USD
		Currency *string `json:"currency,omitempty"`
	} `json:"declared_value,omitempty"`
}

// DaysField defines model for days-field.
type DaysField = []string

// DeliveryObject Delivery details chosen for the shipment, such as chosen delivery type and scheduled delivery date.
type DeliveryObject struct {
	// DeliveryType The type of the delivery. The possible values can be one of the delivery types predefined by the merchant.
	DeliveryType *string `json:"delivery_type,omitempty"`

	// ScheduledDate Scheduled date for delivery provided by the merchant, represented using only the date part of the ISO 8601 format.
	ScheduledDate *openapi_types.Date `json:"scheduled_date,omitempty"`

	// ScheduledFrom Start datetime for delivery provided by the merchant, represented using both the date and time the ISO 8601 format.
	ScheduledFrom *time.Time `json:"scheduled_from,omitempty"`

	// ScheduledTo End datetime for delivery provided by the merchant, represented using both the date and time the ISO 8601 format.
	ScheduledTo *time.Time `json:"scheduled_to,omitempty"`
}

// DeliveryRequest The delivery options chosen for the shipment, including the delivery type and schedule.
//
// # It can be set using one of the following options
//
// Option 1: Provide the `scheduled_from` and `scheduled_to` to choose the scheduled date along with start and end time.
//
// Example:
//
//	"delivery": {
//	  "delivery_type": "STANDARD",
//	  "scheduled_from": "2022-01-01'T'10:00:00.000+1:00",
//	  "scheduled_to": "2022-01-01'T'12:00:00.000+1:00"
//	}
//
// Option 2: Provide the `scheduled_date` only to choose the entire day.
//
// Example:
//
//	"delivery": {
//	  "delivery_type": "STANDARD",
//	  "scheduled_date": "2022-01-01"
//	}
type DeliveryRequest struct {
	// DeliveryType Pass one of the delivery types you have predefined in Carriyo
	DeliveryType *string `json:"delivery_type,omitempty"`

	// ScheduledDate Pass the Scheduled Date to select an entire day
	ScheduledDate *openapi_types.Date `json:"scheduled_date,omitempty"`

	// ScheduledFrom Pass the start date-time
	ScheduledFrom *time.Time `json:"scheduled_from,omitempty"`

	// ScheduledTo Pass the end date-time
	ScheduledTo *time.Time `json:"scheduled_to,omitempty"`
}

// Dimension defines model for dimension.
type Dimension struct {
	Depth  *float32 `json:"depth,omitempty"`
	Height *float32 `json:"height,omitempty"`

	// Unit Default dimension unit is `cm` if not provided.
	Unit  *DimensionUnit `json:"unit,omitempty"`
	Width *float32       `json:"width,omitempty"`
}

// DimensionUnit Default dimension unit is `cm` if not provided.
type DimensionUnit string

// DocumentObject defines model for document-object.
type DocumentObject struct {
	// Format Possible Values:
	// pdf
	Format *string `json:"format,omitempty"`

	// Name Document name
	Name *string `json:"name,omitempty"`

	// Source Possible Values:
	// carriyo, carrier
	Source *string `json:"source,omitempty"`

	// Type Possible Values:
	// commercial_invoice, customer_receipt, delivery_advice, gift_message, packing_list
	Type *string `json:"type,omitempty"`

	// Url The url of document provided by the Carriyo or carrier
	Url *string `json:"url,omitempty"`
}

// ErrorDetail defines model for error-detail.
type ErrorDetail struct {
	// Code Possible Values:
	// required_data_missing, required_data_invalid, merchant_missing, default_merchant_not_configured, phone_number_invalid, email_invalid, email_missing, coordinates_invalid, coordinates_latitude_invalid, coordinates_longitude_invalid, carrier_account_invalid, no_carrier_assigned, partner_location_invalid, time_slot_invalid, status_change_not_allowed, custom_attribute_invalid, custom_attribute_value_invalid, parcel_item_invalid, payment_method_invalid, payment_currency_invalid, country_invalid, postcode_missing, item_origin_country_missing, item_hscode_missing, item_weight_missing, parcel_info_missing, parcel_weight_missing, parcel_dimensions_missing, label_format_invalid, weight_unit_invalid, dimension_unit_invalid, address_field_not_found, template_parsing_failed
	Code  *string `json:"code,omitempty"`
	Field *string `json:"field,omitempty"`

	// Level Possible Values: ERROR, WARNING
	Level   *string `json:"level,omitempty"`
	Message *string `json:"message,omitempty"`

	// Source Possible Values: CARRIYO, CARRIER
	Source *string `json:"source,omitempty"`

	// Trigger Possible Values: BOOKING, CANCELLATION, TRACKING, SCHEDULING
	Trigger *string `json:"trigger,omitempty"`

	// Type Possible Values: VALIDATION, TECHNICAL, UNKNOWN
	Type *string `json:"type,omitempty"`
}

// EstimatedShippingCost The estimated cost of the shipping based either on the costing profile you have configured for the carrier or carrier costing API response
type EstimatedShippingCost struct {
	Amount *float32 `json:"amount,omitempty"`

	// Breakdown The breakdown of shipping cost.
	Breakdown *[]BreakdownObject `json:"breakdown,omitempty"`
	Currency  *string            `json:"currency,omitempty"`
}

// FreeFormRequest Provide the contact and address information
type FreeFormRequest struct {
	// Address1 Address Line 1 (e.g., street, PO Box, or company name).
	Address1 string `json:"address1"`

	// Address2 Address Line 2 (e.g., apartment, floor, unit, or building).
	Address2 *string `json:"address2,omitempty"`

	// AlternatePhone Alternate phone number for contact in E164 Format with country code.  e.g., +16175551210
	AlternatePhone *string `json:"alternate_phone,omitempty"`

	// Area District, suburb or neighbourhood, represented by the Carriyo Area Code if known. If not, it's a free text.
	//
	// Please use the Carriyo standard Area Code when available, to ensure that Carriyo can map this information correctly to the carrier.
	//
	// [Please refer to the Carriyo Geo List for more information.](/guides/carriyo-geo-list)
	Area *string `json:"area,omitempty"`

	// Building Building number or name
	Building *string `json:"building,omitempty"`

	// City City, town, or village, represented by the Carriyo City Code if known. If not, it's a free text.
	//
	// Please use the Carriyo standard City Code when available, to ensure that Carriyo can map this information correctly to the carrier.
	//
	// [Please refer to the Carriyo Geo List for more information.](/guides/carriyo-geo-list)
	City string `json:"city"`

	// CollectionPointId ID of the carrier's collection point for deliveries held at the carrier location for collection
	CollectionPointId *string `json:"collection_point_id,omitempty"`

	// ContactEmail Email address for contact
	// Conditionally mandatory based on Account Settings
	ContactEmail *string `json:"contact_email,omitempty"`

	// ContactName Name of the contact person or business
	ContactName string `json:"contact_name"`

	// ContactPhone Primary phone number for contact in E164 Format with country code.  e.g., +16175551212
	// Conditionally mandatory based on Account Settings
	ContactPhone *string `json:"contact_phone,omitempty"`

	// Coords Latitude and longitude (decimal degrees) of the address as an array. e.g., [25.19741, 55.27442]
	Coords *[]float32 `json:"coords,omitempty"`

	// Country Two-letter country code (ISO 3166-1 alpha-2).
	Country string `json:"country"`

	// CustomFields Custom address fields in the form of a map:
	// ```
	// {"field1" : ["value1", "value2"], "field2" : ["value1", "value2"]}
	// ```
	CustomFields *CustomFields `json:"custom_fields,omitempty"`

	// Flat Flat number
	Flat *string `json:"flat,omitempty"`

	// Floor Floor number
	Floor *string `json:"floor,omitempty"`

	// Notes Any additional notes e.g., "Leave the parcel next to the bin" or "Collect the parcel from the neighbour"
	Notes *string `json:"notes,omitempty"`

	// PersonalId ID of the person to whom the shipment is addressed
	PersonalId *PersonalId `json:"personal_id,omitempty"`

	// PoBox Box number if the address is a PO Box
	PoBox *string `json:"po_box,omitempty"`

	// Postcode ZIP or postal code
	Postcode *string `json:"postcode,omitempty"`

	// State State, county, province, or region, represented by the Carriyo State Code if known. If not, it's a free text.
	//
	// **Note: The state is automatically set if a standard Carriyo city is passed.**
	//
	// [Please refer to the Carriyo Geo List for more information.](/guides/carriyo-geo-list)
	State *string `json:"state,omitempty"`

	// Street Street number or name
	Street *string `json:"street,omitempty"`

	// Type Type of address. i.e. business or residential
	Type       *FreeFormRequestType `json:"type,omitempty"`
	What3words *string              `json:"what3words,omitempty"`
}

// FreeFormRequestType Type of address. i.e. business or residential
type FreeFormRequestType string

// GeographyConditionField defines model for geography-condition-field.
type GeographyConditionField struct {
	Operator *GeographyConditionFieldOperator `json:"operator,omitempty"`
	Value    *[]struct {
		// Country ISO2 country code
		Country     *string `json:"country,omitempty"`
		StateCities *[]struct {
			CityAreas *[]struct {
				Areas *[]string `json:"areas,omitempty"`
				City  *string   `json:"city,omitempty"`
			} `json:"city_areas,omitempty"`
			State *string `json:"state,omitempty"`
		} `json:"state_cities,omitempty"`
	} `json:"value,omitempty"`
}

// GeographyConditionFieldOperator defines model for GeographyConditionField.Operator.
type GeographyConditionFieldOperator string

// ItemObject defines model for item-object.
type ItemObject struct {
	// Barcode Barcode of the item
	Barcode *string `json:"barcode,omitempty"`

	// Cost The unit cost of the item
	Cost *struct {
		Amount float32 `json:"amount"`

		// Currency The three-letter currency code (ISO 4217) for the amount. e.g., USD
		Currency string `json:"currency"`
	} `json:"cost,omitempty"`

	// DangerousGoods If the item is classified as dangerous goods. Usually required for cross-border shipping.
	DangerousGoods *bool `json:"dangerous_goods,omitempty"`

	// Description Description of the item
	Description *string `json:"description,omitempty"`

	// HsCode HS Code of the item. Usually required for cross-border shipping.
	HsCode *string `json:"hs_code,omitempty"`

	// ImageLink Image URL of the item
	ImageLink *string `json:"image_link,omitempty"`

	// Notes Additional information about the item
	Notes *string `json:"notes,omitempty"`

	// OriginCountry Country of origin of the item. Usually required for cross-border shipping.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Price The unit price of the item
	Price *struct {
		Amount float32 `json:"amount"`

		// Currency The three-letter currency code (ISO 4217) for the amount. e.g., USD
		Currency string `json:"currency"`
	} `json:"price,omitempty"`
	Quantity *int `json:"quantity,omitempty"`

	// Sku SKU ID of the item
	Sku *string `json:"sku,omitempty"`

	// Weight The weight of the item
	Weight *struct {
		// Unit Default weight unit is `kg` if not provided.
		Unit  *ItemObjectWeightUnit `json:"unit,omitempty"`
		Value *float32              `json:"value,omitempty"`
	} `json:"weight,omitempty"`
}

// ItemObjectWeightUnit Default weight unit is `kg` if not provided.
type ItemObjectWeightUnit string

// ItemRequest defines model for item-request.
type ItemRequest struct {
	// Barcode Barcode of the item
	Barcode *string `json:"barcode,omitempty"`

	// Battery Battery details of the item. Usually required for cross-border shipping.
	Battery *struct {
		MaterialType *ItemRequestBatteryMaterialType `json:"material_type,omitempty"`
		PackingType  *ItemRequestBatteryPackingType  `json:"packing_type,omitempty"`
	} `json:"battery,omitempty"`

	// Cost The unit cost of the item
	Cost *struct {
		Amount float32 `json:"amount"`

		// Currency The three-letter currency code (ISO 4217) for the amount. e.g., USD
		Currency string `json:"currency"`
	} `json:"cost,omitempty"`

	// DangerousGoods If the item is classified as dangerous goods. Usually required for cross-border shipping.
	DangerousGoods *bool `json:"dangerous_goods,omitempty"`

	// Description Description of the item
	Description string `json:"description"`

	// HsCode HS Code of the item. Usually required for cross-border shipping.
	HsCode *string `json:"hs_code,omitempty"`

	// ImageLink Image URL of the item
	ImageLink *string `json:"image_link,omitempty"`

	// Notes Additional information about the item
	Notes *string `json:"notes,omitempty"`

	// OriginCountry Country of origin of the item. Usually required for cross-border shipping.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Price The unit price of the item
	Price struct {
		Amount float32 `json:"amount"`

		// Currency The three-letter currency code (ISO 4217) for the amount. e.g., USD
		Currency string `json:"currency"`
	} `json:"price"`
	Quantity int `json:"quantity"`

	// Sku SKU ID of the item
	Sku string `json:"sku"`

	// Weight The weight of the item
	Weight *struct {
		// Unit Default weight unit is `kg` if not provided.
		Unit  *ItemRequestWeightUnit `json:"unit,omitempty"`
		Value *float32               `json:"value,omitempty"`
	} `json:"weight,omitempty"`
}

// ItemRequestBatteryMaterialType defines model for ItemRequest.Battery.MaterialType.
type ItemRequestBatteryMaterialType string

// ItemRequestBatteryPackingType defines model for ItemRequest.Battery.PackingType.
type ItemRequestBatteryPackingType string

// ItemRequestWeightUnit Default weight unit is `kg` if not provided.
type ItemRequestWeightUnit string

// LocationObject Either a free-form address or a predefined location.
type LocationObject struct {
	// Address1 Address Line 1 (e.g., street, PO Box, or company name).
	Address1 *string `json:"address1,omitempty"`

	// Address2 Address Line 2 (e.g., apartment, floor, unit, or building).
	Address2 *string `json:"address2,omitempty"`

	// AlternatePhone Alternate phone number for contact in E164 Format with country code.  e.g., +16175551210
	AlternatePhone *string `json:"alternate_phone,omitempty"`

	// Area District, suburb or neighbourhood, represented by the Carriyo Area Code if known. If not, it's a free text.
	//
	// [Please refer to the Carriyo Geo List for more information.](/guides/carriyo-geo-list)
	Area *string `json:"area,omitempty"`

	// AreaCoords (Read-only) Approximate latitude and longitude for the area, if found in Carriyo's database. e.g., [25.1949849, 55.2784141]
	AreaCoords *[]float32 `json:"area_coords,omitempty"`

	// Building Building number or name
	Building *string `json:"building,omitempty"`

	// City City, town, or village, represented by the Carriyo City Code if known. If not, it's a free text.
	//
	// [Please refer to the Carriyo Geo List for more information.](/guides/carriyo-geo-list)
	City *string `json:"city,omitempty"`

	// CityCoords (Read-only) Approximate latitude and longitude for the city, if found in Carriyo's database. e.g., [25.1949849, 55.2784141]
	CityCoords *[]float32 `json:"city_coords,omitempty"`

	// CollectionPointId ID of the carrier's collection point for deliveries held at the carrier location for collection
	CollectionPointId *string `json:"collection_point_id,omitempty"`

	// ContactEmail Email address for contact
	// Conditionally mandatory based on Account Settings
	ContactEmail *string `json:"contact_email,omitempty"`

	// ContactName Name of the contact person or business
	ContactName *string `json:"contact_name,omitempty"`

	// ContactPhone Primary phone number for contact in E164 Format with country code.  e.g., +16175551212
	// Conditionally mandatory based on Account Settings
	ContactPhone *string `json:"contact_phone,omitempty"`

	// Coords Latitude and longitude (decimal degrees) of the address as an array. e.g., [25.19741, 55.27442]
	Coords *[]float32 `json:"coords,omitempty"`

	// Country Two-letter country code (ISO 3166-1 alpha-2).
	Country *string `json:"country,omitempty"`

	// CustomFields Custom address fields in the form of a map:
	// ```
	// {"field1" : ["value1", "value2"], "field2" : ["value1", "value2"]}
	// ```
	CustomFields *CustomFields `json:"custom_fields,omitempty"`

	// Flat Flat number
	Flat *string `json:"flat,omitempty"`

	// Floor Floor number
	Floor *string `json:"floor,omitempty"`

	// InputArea (Ready-only) Preserves the original input provided for "area". It is useful when Carriyo is instructed to automatically recognise the Carriyo area code.
	InputArea *string `json:"input_area,omitempty"`

	// InputCity (Ready-only) Preserves the original input provided for "city". It is useful when Carriyo is instructed to automatically recognise the Carriyo city code.
	InputCity *string `json:"input_city,omitempty"`

	// InputState (Ready-only) Preserves the original input provided for "state". It is useful when Carriyo is instructed to automatically recognise the Carriyo state code.
	InputState *string `json:"input_state,omitempty"`

	// Notes Any additional notes e.g., "Leave the parcel next to the bin" or "Collect the parcel from the neighbour"
	Notes *string `json:"notes,omitempty"`

	// PartnerLocationId ID of the location chosen by the merchant
	PartnerLocationId *string `json:"partner_location_id,omitempty"`

	// PersonalId ID of the person to whom the shipment is addressed
	PersonalId *PersonalId `json:"personal_id,omitempty"`

	// PoBox Box number if the address is a PO Box
	PoBox *string `json:"po_box,omitempty"`

	// Postcode ZIP or postal code
	Postcode *string `json:"postcode,omitempty"`

	// State State, county, province, or region, represented by the Carriyo State Code if known. If not, it's a free text.
	//
	// [Please refer to the Carriyo Geo List for more information.](/guides/carriyo-geo-list)
	State *string `json:"state,omitempty"`

	// Street Street number or name
	Street *string `json:"street,omitempty"`

	// Type Type of address. i.e. business or residential
	Type       *LocationObjectType `json:"type,omitempty"`
	What3words *string             `json:"what3words,omitempty"`
}

// LocationObjectType Type of address. i.e. business or residential
type LocationObjectType string

// LocationRequest Specify the Carriyo location ID (`partner_location_id`), or the location code (`partner_location_code`) you defined when you created the location in Carriyo.
type LocationRequest struct {
	// PartnerLocationCode You can also pass the unique locaton code intead of the location id
	PartnerLocationCode *string `json:"partner_location_code,omitempty"`

	// PartnerLocationId Carriyo's internal location id to use for the pickup
	PartnerLocationId *string `json:"partner_location_id,omitempty"`
}

// ManifestRequest defines model for manifest-request.
type ManifestRequest struct {
	CarrierAccount     string                 `json:"carrier_account"`
	Merchant           string                 `json:"merchant"`
	Pickup             map[string]interface{} `json:"pickup"`
	PickupScheduleFrom string                 `json:"pickup_schedule_from"`
	PickupScheduleTo   string                 `json:"pickup_schedule_to"`
	ShipManifestDate   string                 `json:"ship_manifest_date"`
	ShipmentIds        []string               `json:"shipment_ids"`
}

// ManifestResponse defines model for manifest-response.
type ManifestResponse struct {
	CarrierAccount     string                 `json:"carrier_account"`
	ManifestId         string                 `json:"manifest_id"`
	Merchant           string                 `json:"merchant"`
	Pickup             map[string]interface{} `json:"pickup"`
	PickupScheduleFrom string                 `json:"pickup_schedule_from"`
	PickupScheduleTo   string                 `json:"pickup_schedule_to"`
	ShipManifestDate   string                 `json:"ship_manifest_date"`
	ShipmentIds        []string               `json:"shipment_ids"`
}

// NumberAreaConditionField defines model for number-area-condition-field.
type NumberAreaConditionField struct {
	MaxValue *float32 `json:"max_value,omitempty"`
	MinValue *float32 `json:"min_value,omitempty"`
}

// PackageObject List of packages of type pallet or carton in a B2B shipment.
type PackageObject struct {
	Dimension *Dimension `json:"dimension,omitempty"`

	// PackageReference A reference number to identify the package
	PackageReference *string `json:"package_reference,omitempty"`

	// Parent A reference number to identify the parent package
	Parent *string      `json:"parent,omitempty"`
	Type   *interface{} `json:"type,omitempty"`
	Weight *Weight      `json:"weight,omitempty"`
}

// ParcelItem defines model for parcel-item.
type ParcelItem struct {
	Quantity *int    `json:"quantity,omitempty"`
	Sku      *string `json:"sku,omitempty"`
}

// ParcelObject List of parcels in a B2C shipment.
type ParcelObject struct {
	// Description Description for the parcel provided by the merchant
	Description *string    `json:"description,omitempty"`
	Dimension   *Dimension `json:"dimension,omitempty"`

	// ParcelId Unique parcel ID generated by Carriyo
	ParcelId    *string       `json:"parcel_id,omitempty"`
	ParcelItems *[]ParcelItem `json:"parcel_items,omitempty"`

	// PartnerParcelReference Unique parcel reference provided by the merchant
	PartnerParcelReference *string `json:"partner_parcel_reference,omitempty"`
	Weight                 *Weight `json:"weight,omitempty"`
}

// ParcelRequest List of parcels in a B2C shipment.
type ParcelRequest struct {
	// Description A description for the parcel
	Description *string       `json:"description,omitempty"`
	Dimension   *Dimension    `json:"dimension,omitempty"`
	ParcelItems *[]ParcelItem `json:"parcel_items,omitempty"`

	// PartnerParcelReference A reference number to identify the parcel
	PartnerParcelReference *string `json:"partner_parcel_reference,omitempty"`
	Weight                 *Weight `json:"weight,omitempty"`
}

// PaymentObject Payment details including the total value of the shipment and any pending Cash on Delivery amount.
type PaymentObject struct {
	// Currency The three-letter currency code (ISO 4217) for the amount. e.g., USD
	Currency *string `json:"currency,omitempty"`

	// PaymentMode Payment mode of the shipment can be `PRE_PAID` or `CASH_ON_DELIVERY`. It defaults to `PRE_PAID` for reverse shipment or if no input is provided.
	//
	// `PRE_PAID` is the only valid value for reverse shipments.
	PaymentMode *PaymentObjectPaymentMode `json:"payment_mode,omitempty"`

	// PendingAmount Outstanding amount payable on delivery of the shipment. It defaults to 0 if no input is provided.
	PendingAmount *float64 `json:"pending_amount,omitempty"`

	// TotalAmount Total value of the shipment
	TotalAmount *float64 `json:"total_amount,omitempty"`
}

// PaymentObjectPaymentMode Payment mode of the shipment can be `PRE_PAID` or `CASH_ON_DELIVERY`. It defaults to `PRE_PAID` for reverse shipment or if no input is provided.
//
// `PRE_PAID` is the only valid value for reverse shipments.
type PaymentObjectPaymentMode string

// PaymentRequest Payment details including the total value of the shipment and any pending Cash on Delivery amount.
type PaymentRequest struct {
	// Currency The three-letter currency code (ISO 4217) for the amount. e.g., USD
	Currency string `json:"currency"`

	// PaymentMode Payment mode of the shipment can be `PRE_PAID` or `CASH_ON_DELIVERY`. It defaults to `PRE_PAID` for reverse shipment or if no input is provided.
	//
	// `PRE_PAID` is the only valid value for reverse shipments.
	PaymentMode *PaymentRequestPaymentMode `json:"payment_mode,omitempty"`

	// PendingAmount Outstanding amount payable on delivery of the shipment. It defaults to 0 for reverse shipment or if no input is provided.
	PendingAmount *float64 `json:"pending_amount,omitempty"`

	// TotalAmount Total value of the shipment
	TotalAmount float64 `json:"total_amount"`
}

// PaymentRequestPaymentMode Payment mode of the shipment can be `PRE_PAID` or `CASH_ON_DELIVERY`. It defaults to `PRE_PAID` for reverse shipment or if no input is provided.
//
// `PRE_PAID` is the only valid value for reverse shipments.
type PaymentRequestPaymentMode string

// PersonalId ID of the person to whom the shipment is addressed
type PersonalId struct {
	// Id ID number
	Id *string `json:"id,omitempty"`

	// Type ID type
	Type *string `json:"type,omitempty"`
}

// PostShippingInfo Booking details such as tracking number, labels etc.
type PostShippingInfo struct {
	// CarrierPdfLabelUrl The url of PDF label provided by the carrier
	CarrierPdfLabelUrl *string `json:"carrier_pdf_label_url,omitempty"`

	// CarrierStatus The raw status provided by the carrier
	CarrierStatus *string `json:"carrier_status,omitempty"`

	// CarrierStatusDate The Date when the carrier status was last updated in ISO 8601 format. Example: 2022-01-01T17:07:05.000Z
	CarrierStatusDate *time.Time `json:"carrier_status_date,omitempty"`

	// CarrierStatusDescription The status description provided by the carrier
	CarrierStatusDescription *string `json:"carrier_status_description,omitempty"`

	// CarrierStatusLocation The last known location of the shipment provided by the carrier. For example: Dubai
	CarrierStatusLocation *string `json:"carrier_status_location,omitempty"`

	// CarrierTrackingUrl The url of tracking page provided by the carrier
	CarrierTrackingUrl *string `json:"carrier_tracking_url,omitempty"`

	// CarriyoFeedbackUrl The url of feedback page provided by the Carriyo
	CarriyoFeedbackUrl *string `json:"carriyo_feedback_url,omitempty"`

	// CarriyoPdfLabelUrl The url of PDF label generated by Carriyo
	CarriyoPdfLabelUrl *string `json:"carriyo_pdf_label_url,omitempty"`

	// CarriyoPinpointUrl The url of pinpoint page provided by the Carriyo
	CarriyoPinpointUrl *string `json:"carriyo_pinpoint_url,omitempty"`

	// CarriyoTrackingUrl The url of tracking page provided by the Carriyo
	CarriyoTrackingUrl *string `json:"carriyo_tracking_url,omitempty"`

	// CarriyoZplLabelUrl The url of ZPL label generated by Carriyo
	CarriyoZplLabelUrl *string `json:"carriyo_zpl_label_url,omitempty"`

	// DefaultLabelUrl The url for the default label - either carrier or carriyo generated
	DefaultLabelUrl *string `json:"default_label_url,omitempty"`

	// Documents Shipping documents such as commercial invoice, packing list etc
	Documents *[]DocumentObject `json:"documents,omitempty"`

	// DriverName The name of the driver delivering the shipment
	DriverName *string `json:"driver_name,omitempty"`

	// DriverPhone The phone number of the driver delivering the shipment
	DriverPhone  *string        `json:"driver_phone,omitempty"`
	ErrorDetails *[]ErrorDetail `json:"error_details,omitempty"`

	// EstimatedDeliveryDate The date the shipment is expected to be delivered in ISO 8601 format. Example: 2022-01-01T17:07:05.000Z
	EstimatedDeliveryDate *time.Time `json:"estimated_delivery_date,omitempty"`

	// EstimatedShipDate The date the shipment is expected to be shipped in ISO 8601 format. Example: 2022-03-01T17:07:05.000Z
	EstimatedShipDate *time.Time `json:"estimated_ship_date,omitempty"`

	// FailedDeliveryAttempts The total number of failed delivery attempts on the shipment
	FailedDeliveryAttempts *float32 `json:"failed_delivery_attempts,omitempty"`
	KeyMilestones          *struct {
		AwaitingCustomerCollection *string `json:"awaiting_customer_collection,omitempty"`
		Booked                     *string `json:"booked,omitempty"`
		Cancelled                  *string `json:"cancelled,omitempty"`
		CancelledByCarrier         *string `json:"cancelled_by_carrier,omitempty"`
		Delayed                    *string `json:"delayed,omitempty"`
		Delivered                  *string `json:"delivered,omitempty"`
		DeliveryConfirmed          *string `json:"delivery_confirmed,omitempty"`
		Error                      *string `json:"error,omitempty"`
		FailedCollectionAttempt    *string `json:"failed_collection_attempt,omitempty"`
		FailedDeliveryAttempt      *string `json:"failed_delivery_attempt,omitempty"`
		InTransit                  *string `json:"in_transit,omitempty"`
		Missing                    *string `json:"missing,omitempty"`
		OutForDelivery             *string `json:"out_for_delivery,omitempty"`
		Pending                    *string `json:"pending,omitempty"`
		ReadyForReturn             *string `json:"ready_for_return,omitempty"`
		ReadyToShip                *string `json:"ready_to_ship,omitempty"`
		ReturnConfirmed            *string `json:"return_confirmed,omitempty"`
		ReturnInTransit            *string `json:"return_in_transit,omitempty"`
		Returned                   *string `json:"returned,omitempty"`
		Shipped                    *string `json:"shipped,omitempty"`
		Suspended                  *string `json:"suspended,omitempty"`
	} `json:"key_milestones,omitempty"`

	// ParcelTrackingNumbers Tracking numbers for individual parcels if generated by the carrier
	ParcelTrackingNumbers *[]struct {
		ParcelId       *string `json:"parcel_id,omitempty"`
		TrackingNumber *string `json:"tracking_number,omitempty"`
	} `json:"parcel_tracking_numbers,omitempty"`

	// ProofOfDelivery The url of document or image containing the proof of delivery
	ProofOfDelivery *string `json:"proof_of_delivery,omitempty"`

	// ReasonCode The reason code linked to the status (one of the standard Carriyo reason codes or a merchant defined status)
	ReasonCode *string `json:"reason_code,omitempty"`

	// RecipientName The name of the recipient to whom shipment was delivered
	RecipientName *string `json:"recipient_name,omitempty"`

	// Status The status of the shipment (one of the standard Carriyo status)
	Status *string `json:"status,omitempty"`

	// TrackingNo The unique shipment tracking number provided by the carrier
	TrackingNo *string `json:"tracking_no,omitempty"`
}

// PromisedDeliveryDateRequest Revised promised delivery date
type PromisedDeliveryDateRequest struct {
	// RevisedPromisedDeliveryDate Revised promised delivery date in ISO 8601 format. For Example: 2020-09-03T17:07:05.000+1:00 represents the date-time in UTC+1 time zone or 2020-09-03T17:07:05.000Z represents date-time in UTC (zulu) time zone
	RevisedPromisedDeliveryDate *time.Time `json:"revised_promised_delivery_date,omitempty"`
}

// ReferencesObject References for a shipment, provided by the merchant.
type ReferencesObject struct {
	// AlternateReference An alternate reference that can be used for searching shipments in Carriyo or mapping references to the carrier.
	AlternateReference *string `json:"alternate_reference,omitempty"`

	// OtherReferences A list of references that can be used for searching shipments in Carriyo
	OtherReferences *[]string `json:"other_references,omitempty"`

	// PartnerOrderReference Order reference provided by the merchant
	PartnerOrderReference *string `json:"partner_order_reference,omitempty"`

	// PartnerShipmentReference Unique shipment reference provided by the merchant
	PartnerShipmentReference *string `json:"partner_shipment_reference,omitempty"`
}

// ReferencesRequest References for a shipment, provided by the merchant.
//
// The `partner_order_reference` is mandatory but not required to be unique. It is usually the customer facing order number.
//
// The `partner_shipment_reference` must be unique for every shipment. It is mandatory, but is copied from `partner_order_reference` if it is not provided.
//
// If a single order has multiple shipments, then they will share the `partner_order_reference` but have unique `partner_shipment_reference`.
type ReferencesRequest struct {
	// AlternateReference An alternate reference that can be used for searching shipments in Carriyo or mapping references to the carrier.
	AlternateReference *string `json:"alternate_reference,omitempty"`

	// OtherReferences A list of references that can be used for searching shipments in Carriyo
	OtherReferences *[]string `json:"other_references,omitempty"`

	// PartnerOrderReference Order reference provided by the merchant
	PartnerOrderReference string `json:"partner_order_reference"`

	// PartnerShipmentReference Unique shipment reference provided by the merchant
	PartnerShipmentReference string `json:"partner_shipment_reference"`
}

// RulesetRequest defines model for ruleset-request.
type RulesetRequest struct {
	// Countries List of country iso2 codes used in Ruleset. Use ["_ANY"] for all countries
	Countries  []string                 `json:"countries"`
	EntityType RulesetRequestEntityType `json:"entity_type"`

	// Merchants List of Merchant ids used in Ruleset. Use ["_ANY"] for all merchants
	Merchants []string    `json:"merchants"`
	Name      string      `json:"name"`
	Status    StatusField `json:"status"`
}

// RulesetRequestEntityType defines model for RulesetRequest.EntityType.
type RulesetRequestEntityType string

// RulesetResponse defines model for ruleset-response.
type RulesetResponse struct {
	// Countries List of country iso2 codes used in Ruleset. Use ["_ANY"] for all countries
	Countries    *[]string                  `json:"countries,omitempty"`
	CreationDate *time.Time                 `json:"creation_date,omitempty"`
	EntityType   *RulesetResponseEntityType `json:"entity_type,omitempty"`

	// Merchants List of Merchant ids used in Ruleset. Use ["_ANY"] for all merchants
	Merchants  *[]string    `json:"merchants,omitempty"`
	Name       *string      `json:"name,omitempty"`
	RuleSetId  *string      `json:"rule_set_id,omitempty"`
	Status     *StatusField `json:"status,omitempty"`
	Tenant     *string      `json:"tenant,omitempty"`
	UpdateDate *time.Time   `json:"update_date,omitempty"`
}

// RulesetResponseEntityType defines model for RulesetResponse.EntityType.
type RulesetResponseEntityType string

// SequencesRequest defines model for sequences-request.
type SequencesRequest = []struct {
	RuleId   *string  `json:"rule_id,omitempty"`
	Sequence *float32 `json:"sequence,omitempty"`
}

// ServiceLevelRuleRequest defines model for service-level-rule-request.
type ServiceLevelRuleRequest struct {
	// CarrierIds shipment.source.source_type matches condition
	CarrierIds *StringConditionField              `json:"carrier_ids,omitempty"`
	ConfigType *ServiceLevelRuleRequestConfigType `json:"config_type,omitempty"`

	// CustomConditions shipment.custom_attributes matches condition
	CustomConditions *CustomAttributesConditionField `json:"custom_conditions,omitempty"`

	// Days Days when rule applies
	Days *DaysField `json:"days,omitempty"`

	// DeliveryType shipment.delivery.delivery_type matches condition
	DeliveryType *StringConditionField `json:"delivery_type,omitempty"`
	Description  *string               `json:"description,omitempty"`

	// DropoffPartnerLocationIds shipment.dropoff.partner_location_id matches condition
	DropoffPartnerLocationIds *StringConditionField `json:"dropoff_partner_location_ids,omitempty"`

	// DropoffV2 shipment.dropoff country state city area condition
	DropoffV2 *GeographyConditionField `json:"dropoff_v2,omitempty"`

	// EndTime Time range when rule applies
	EndTime *float32 `json:"end_time,omitempty"`

	// GrossWeight shipment.parcels gross weight is inside range
	GrossWeight *NumberAreaConditionField `json:"gross_weight,omitempty"`

	// Merchants shipment.merchant matches condition
	Merchants *StringConditionField `json:"merchants,omitempty"`

	// OrderType shipment.order_type matches condition
	OrderType *StringConditionField `json:"order_type,omitempty"`

	// PickupPartnerLocationIds shipment.pickup.partner_location_id matches condition
	PickupPartnerLocationIds *StringConditionField `json:"pickup_partner_location_ids,omitempty"`

	// PickupV2 shipment.pickup country state city area condition
	PickupV2 *GeographyConditionField `json:"pickup_v2,omitempty"`
	RuleName string                   `json:"rule_name"`

	// Sequence Sequence number used for rules prioritisation (lower is more important)
	Sequence float32 `json:"sequence"`

	// SourceType shipment.source.source_type matches condition
	SourceType *StringConditionField `json:"source_type,omitempty"`

	// StartTime Time range when rule applies
	StartTime *float32    `json:"start_time,omitempty"`
	Status    StatusField `json:"status"`

	// VolumetricWeight shipment.parcels volumetric weight is inside range
	VolumetricWeight *NumberAreaConditionField `json:"volumetric_weight,omitempty"`
}

// ServiceLevelRuleRequestConfigType defines model for ServiceLevelRuleRequest.ConfigType.
type ServiceLevelRuleRequestConfigType string

// ServiceLevelRuleResponse defines model for service-level-rule-response.
type ServiceLevelRuleResponse struct {
	CarrierIds                *StringConditionField               `json:"carrier_ids,omitempty"`
	ConfigType                *ServiceLevelRuleResponseConfigType `json:"config_type,omitempty"`
	CreationDate              *time.Time                          `json:"creation_date,omitempty"`
	CustomConditions          *CustomAttributesConditionField     `json:"custom_conditions,omitempty"`
	Days                      *DaysField                          `json:"days,omitempty"`
	DeliveryType              *StringConditionField               `json:"delivery_type,omitempty"`
	Description               *string                             `json:"description,omitempty"`
	DropoffPartnerLocationIds *StringConditionField               `json:"dropoff_partner_location_ids,omitempty"`
	DropoffV2                 *GeographyConditionField            `json:"dropoff_v2,omitempty"`
	EndTime                   *float32                            `json:"end_time,omitempty"`
	GrossWeight               *NumberAreaConditionField           `json:"gross_weight,omitempty"`
	Merchants                 *StringConditionField               `json:"merchants,omitempty"`
	OrderType                 *StringConditionField               `json:"order_type,omitempty"`
	PickupPartnerLocationIds  *StringConditionField               `json:"pickup_partner_location_ids,omitempty"`
	PickupV2                  *GeographyConditionField            `json:"pickup_v2,omitempty"`
	RuleId                    *string                             `json:"rule_id,omitempty"`
	RuleName                  *string                             `json:"rule_name,omitempty"`
	RuleSetId                 *string                             `json:"rule_set_id,omitempty"`
	Sequence                  *float32                            `json:"sequence,omitempty"`
	SourceType                *StringConditionField               `json:"source_type,omitempty"`
	StartTime                 *float32                            `json:"start_time,omitempty"`
	Status                    *StatusField                        `json:"status,omitempty"`
	Tenant                    *string                             `json:"tenant,omitempty"`
	UpdateDate                *time.Time                          `json:"update_date,omitempty"`
	VolumetricWeight          *NumberAreaConditionField           `json:"volumetric_weight,omitempty"`
}

// ServiceLevelRuleResponseConfigType defines model for ServiceLevelRuleResponse.ConfigType.
type ServiceLevelRuleResponseConfigType string

// ServiceLevelRulesetWithRulesRequest defines model for service-level-ruleset-with-rules-request.
type ServiceLevelRulesetWithRulesRequest struct {
	AutomationRuleSet RulesetRequest             `json:"automation_rule_set"`
	AutomationRules   *[]ServiceLevelRuleRequest `json:"automation_rules,omitempty"`
}

// ServiceLevelRulesetWithRulesResponse defines model for service-level-ruleset-with-rules-response.
type ServiceLevelRulesetWithRulesResponse struct {
	AutomationRuleSet RulesetResponse             `json:"automation_rule_set"`
	AutomationRules   *[]ServiceLevelRuleResponse `json:"automation_rules,omitempty"`
}

// ShipmentDraftRequest defines model for shipment-draft-request.
type ShipmentDraftRequest struct {
	// CarrierAccount Carrier account chosen for the shipment. Should contain either the carrier account id or carrier account name. Carrier account id takes precedence if both fields are passed.
	CarrierAccount *CarrierAccountRequest `json:"carrier_account,omitempty"`

	// Collection Collection details chosen for the shipment, such as scheduled collection date.
	//
	// It can be set using one of the following options
	//
	// Option 1: Provide the `scheduled_from` and `scheduled_to` to choose the scheduled date along with start and end time.
	//
	// Example:
	// "collection": {
	//   "scheduled_from": "2022-01-01'T'10:00:00.000+1:00",
	//   "scheduled_to": "2022-01-01'T'12:00:00.000+1:00"
	// }
	//
	// Option 2: Provide the `scheduled_date` only to choose the entire day.
	//
	// Example:
	// "collection": {
	//   "scheduled_date": "2022-01-01"
	// }
	Collection *CollectionRequest `json:"collection,omitempty"`

	// CustomAttributes Custom attributes in the form of a map:
	// ```
	// {"attribute1" : ["value1", "value2"], "attribute2" : ["value1", "value2"]}
	// ```
	// Please Note: You can only use custom attributes if you are subscribed to this feature.
	CustomAttributes *CustomAttributes `json:"custom_attributes,omitempty"`

	// Customs Customs declaration details such as total declared value.
	Customs *CustomsObject `json:"customs,omitempty"`

	// Delivery The delivery options chosen for the shipment, including the delivery type and schedule.
	//
	// It can be set using one of the following options
	//
	// Option 1: Provide the `scheduled_from` and `scheduled_to` to choose the scheduled date along with start and end time.
	//
	// Example:
	// "delivery": {
	//   "delivery_type": "STANDARD",
	//   "scheduled_from": "2022-01-01'T'10:00:00.000+1:00",
	//   "scheduled_to": "2022-01-01'T'12:00:00.000+1:00"
	// }
	//
	// Option 2: Provide the `scheduled_date` only to choose the entire day.
	//
	// Example:
	// "delivery": {
	//   "delivery_type": "STANDARD",
	//   "scheduled_date": "2022-01-01"
	// }
	Delivery *DeliveryRequest `json:"delivery,omitempty"`

	// Dropoff Dropoff address for the shipment. You can either pass a free-form address or a predefined location.
	//
	// For forward shipments, you can pass the customer's dropoff address as a free-form address.
	//
	// For reverse shipments, you must pass a predefined dropoff location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
	Dropoff    *ShipmentDraftRequest_Dropoff   `json:"dropoff,omitempty"`
	EntityType *ShipmentDraftRequestEntityType `json:"entity_type,omitempty"`

	// Freight List of packages of type pallet or carton in a B2B shipment.
	Freight *struct {
		Packages *[]PackageObject `json:"packages,omitempty"`
	} `json:"freight,omitempty"`

	// Items List of individual items or SKUs in a shipment.
	Items *[]ItemRequest `json:"items,omitempty"`

	// Language Two letter ISO 639-1 code. Example: en
	Language *string `json:"language,omitempty"`

	// Merchant Merchant ID is mandatory to create a shipment
	Merchant string `json:"merchant"`

	// OrderDate Date-time in ISO 8601 format.
	//
	// Example: 2020-09-03T17:07:05.000+1:00 represents the date-time in UTC+1 time zone or 2020-09-03T17:07:05.000Z represents date-time in UTC (zulu) time zone
	OrderDate *time.Time `json:"order_date,omitempty"`

	// OrderType Pass one of the order types you have predefined in Carriyo
	OrderType *string `json:"order_type,omitempty"`

	// Parcels List of parcels in a B2C shipment.
	Parcels *[]ParcelRequest `json:"parcels,omitempty"`

	// Payment Payment details including the total value of the shipment and any pending Cash on Delivery amount.
	Payment *PaymentRequest `json:"payment,omitempty"`

	// Pickup Pickup address for the shipment. You can either pass a free-form address or a predefined location.
	//
	// For forward shipments, you must pass a predefined pickup location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
	//
	// For reverse shipments, you can pass the customer's pickup address as a free-form pickup address.
	Pickup *ShipmentDraftRequest_Pickup `json:"pickup,omitempty"`

	// References References for a shipment, provided by the merchant.
	//
	// The `partner_order_reference` is mandatory but not required to be unique. It is usually the customer facing order number.
	//
	// The `partner_shipment_reference` must be unique for every shipment. It is mandatory, but is copied from `partner_order_reference` if it is not provided.
	//
	// If a single order has multiple shipments, then they will share the `partner_order_reference` but have unique `partner_shipment_reference`.
	References ReferencesRequest `json:"references"`
}

// ShipmentDraftRequest_Dropoff Dropoff address for the shipment. You can either pass a free-form address or a predefined location.
//
// For forward shipments, you can pass the customer's dropoff address as a free-form address.
//
// For reverse shipments, you must pass a predefined dropoff location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
type ShipmentDraftRequest_Dropoff struct {
	union json.RawMessage
}

// ShipmentDraftRequestEntityType defines model for ShipmentDraftRequest.EntityType.
type ShipmentDraftRequestEntityType string

// ShipmentDraftRequest_Pickup Pickup address for the shipment. You can either pass a free-form address or a predefined location.
//
// For forward shipments, you must pass a predefined pickup location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
//
// For reverse shipments, you can pass the customer's pickup address as a free-form pickup address.
type ShipmentDraftRequest_Pickup struct {
	union json.RawMessage
}

// ShipmentObject defines model for shipment-object.
type ShipmentObject struct {
	// CarrierAccount Carrier account chosen for the shipment.
	CarrierAccount *CarrierAccountObject `json:"carrier_account,omitempty"`

	// Collection Collection details chosen for the shipment, such as scheduled collection date.
	Collection *CollectionObject `json:"collection,omitempty"`

	// ConfirmationDate The date the shipment was confirmed for booking
	ConfirmationDate *time.Time `json:"confirmation_date,omitempty"`

	// CreationDate The date the shipment was created in Carriyo
	CreationDate *time.Time `json:"creation_date,omitempty"`

	// CustomAttributes Additional custom attributes provided by the merchant.
	CustomAttributes *map[string]interface{} `json:"custom_attributes,omitempty"`

	// Customs Customs declaration details such as total declared value.
	Customs *CustomsObject `json:"customs,omitempty"`

	// Delivery Delivery details chosen for the shipment, such as chosen delivery type and scheduled delivery date.
	Delivery *DeliveryObject `json:"delivery,omitempty"`

	// Dropoff Either a free-form address or a predefined location.
	Dropoff *LocationObject `json:"dropoff,omitempty"`

	// EntityType The type of the shipment is either FORWARD or REVERSE
	EntityType *ShipmentObjectEntityType `json:"entity_type,omitempty"`

	// EstimatedProcessDate The date the shipment is expected to be processed in ISO 8601 format. Example: 2022-03-01T17:07:05.000Z
	EstimatedProcessDate *time.Time `json:"estimated_process_date,omitempty"`

	// EstimatedShippingCost The estimated cost of the shipping based either on the costing profile you have configured for the carrier or carrier costing API response
	EstimatedShippingCost *EstimatedShippingCost `json:"estimated_shipping_cost,omitempty"`

	// Freight List of packages of type pallet or carton in a B2B shipment.
	Freight *struct {
		Packages *[]PackageObject `json:"packages,omitempty"`
	} `json:"freight,omitempty"`

	// Items List of individual items or SKUs in a shipment.
	Items *[]ItemObject `json:"items,omitempty"`

	// Language Two letter ISO 639-1 code. Example: en
	Language *string `json:"language,omitempty"`

	// Merchant ID of the merchant that created this shipment
	Merchant *string `json:"merchant,omitempty"`

	// OrderDate The date the customer order was received by the merchant
	OrderDate *time.Time `json:"order_date,omitempty"`

	// OrderType The type of the order. The possible values can be one of the order types predefined by the merchant.
	OrderType *string `json:"order_type,omitempty"`

	// OriginalPromisedDeliveryDate The original promised delivery date for the shipment in ISO 8601 format (if the promise is updated). Example: 2022-03-01T17:07:05.000Z
	OriginalPromisedDeliveryDate *time.Time `json:"original_promised_delivery_date,omitempty"`

	// Parcels List of parcels in a B2C shipment.
	Parcels *[]ParcelObject `json:"parcels,omitempty"`

	// Payment Payment details including the total value of the shipment and any pending Cash on Delivery amount.
	Payment *PaymentObject `json:"payment,omitempty"`

	// Pickup Either a free-form address or a predefined location.
	Pickup *LocationObject `json:"pickup,omitempty"`

	// PostShippingInfo Booking details such as tracking number, labels etc.
	PostShippingInfo *PostShippingInfo `json:"post_shipping_info,omitempty"`

	// PromisedDeliveryDate The promised delivery date for the shipment in ISO 8601 format. Example: 2022-03-01T17:07:05.000Z
	PromisedDeliveryDate *time.Time `json:"promised_delivery_date,omitempty"`

	// References References for a shipment, provided by the merchant.
	References *ReferencesObject `json:"references,omitempty"`

	// ReturnRequestId ID of the Return request that initiated the reverse shipment
	ReturnRequestId *string `json:"return_request_id,omitempty"`

	// ShipmentId Unique identifier for the shipment
	ShipmentId *string `json:"shipment_id,omitempty"`

	// UpdateDate The date the shipment was last updated in Carriyo
	UpdateDate *time.Time `json:"update_date,omitempty"`
}

// ShipmentObjectEntityType The type of the shipment is either FORWARD or REVERSE
type ShipmentObjectEntityType string

// ShipmentPatchRequest defines model for shipment-patch-request.
type ShipmentPatchRequest struct {
	// CarrierAccount Carrier account chosen for the shipment. Should contain either the carrier account id or carrier account name. Carrier account id takes precedence if both fields are passed.
	CarrierAccount *CarrierAccountRequest `json:"carrier_account,omitempty"`

	// Collection Collection details chosen for the shipment, such as scheduled collection date.
	//
	// It can be set using one of the following options
	//
	// Option 1: Provide the `scheduled_from` and `scheduled_to` to choose the scheduled date along with start and end time.
	//
	// Example:
	// "collection": {
	//   "scheduled_from": "2022-01-01'T'10:00:00.000+1:00",
	//   "scheduled_to": "2022-01-01'T'12:00:00.000+1:00"
	// }
	//
	// Option 2: Provide the `scheduled_date` only to choose the entire day.
	//
	// Example:
	// "collection": {
	//   "scheduled_date": "2022-01-01"
	// }
	Collection *CollectionRequest `json:"collection,omitempty"`

	// CustomAttributes Custom attributes in the form of a map:
	// ```
	// {"attribute1" : ["value1", "value2"], "attribute2" : ["value1", "value2"]}
	// ```
	// Please Note: You can only use custom attributes if you are subscribed to this feature.
	CustomAttributes *CustomAttributes `json:"custom_attributes,omitempty"`

	// Customs Customs declaration details such as total declared value.
	Customs *CustomsObject `json:"customs,omitempty"`

	// Delivery The delivery options chosen for the shipment, including the delivery type and schedule.
	//
	// It can be set using one of the following options
	//
	// Option 1: Provide the `scheduled_from` and `scheduled_to` to choose the scheduled date along with start and end time.
	//
	// Example:
	// "delivery": {
	//   "delivery_type": "STANDARD",
	//   "scheduled_from": "2022-01-01'T'10:00:00.000+1:00",
	//   "scheduled_to": "2022-01-01'T'12:00:00.000+1:00"
	// }
	//
	// Option 2: Provide the `scheduled_date` only to choose the entire day.
	//
	// Example:
	// "delivery": {
	//   "delivery_type": "STANDARD",
	//   "scheduled_date": "2022-01-01"
	// }
	Delivery *DeliveryRequest `json:"delivery,omitempty"`

	// Dropoff Dropoff address for the shipment. You can either pass a free-form address or a predefined location.
	//
	// For forward shipments, you can pass the customer's dropoff address as a free-form address.
	//
	// For reverse shipments, you must pass a predefined dropoff location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) defined when you created the location in Carriyo.
	Dropoff *ShipmentPatchRequest_Dropoff `json:"dropoff,omitempty"`

	// Freight List of packages of type pallet or carton in a B2B shipment.
	Freight *struct {
		Packages *[]PackageObject `json:"packages,omitempty"`
	} `json:"freight,omitempty"`

	// Items List of individual items or SKUs in a shipment.
	Items     *[]ItemRequest `json:"items,omitempty"`
	OrderDate *time.Time     `json:"order_date,omitempty"`

	// OrderType Pass one of the order types you have predefined in Carriyo
	OrderType *string `json:"order_type,omitempty"`

	// Parcels List of parcels in a B2C shipment.
	Parcels *[]ParcelRequest `json:"parcels,omitempty"`

	// Payment Payment details including the total value of the shipment and any pending Cash on Delivery amount.
	Payment *PaymentRequest `json:"payment,omitempty"`

	// Pickup Pickup address for the shipment. You can either pass a free-form address or a predefined location.
	//
	// For forward shipments, you must pass a predefined pickup location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) defined when you created the location in Carriyo.
	//
	// For reverse shipments, you can pass the customer's pickup address as a free-form pickup address.
	Pickup *ShipmentPatchRequest_Pickup `json:"pickup,omitempty"`
}

// ShipmentPatchRequest_Dropoff Dropoff address for the shipment. You can either pass a free-form address or a predefined location.
//
// For forward shipments, you can pass the customer's dropoff address as a free-form address.
//
// For reverse shipments, you must pass a predefined dropoff location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) defined when you created the location in Carriyo.
type ShipmentPatchRequest_Dropoff struct {
	union json.RawMessage
}

// ShipmentPatchRequest_Pickup Pickup address for the shipment. You can either pass a free-form address or a predefined location.
//
// For forward shipments, you must pass a predefined pickup location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) defined when you created the location in Carriyo.
//
// For reverse shipments, you can pass the customer's pickup address as a free-form pickup address.
type ShipmentPatchRequest_Pickup struct {
	union json.RawMessage
}

// ShipmentRequest defines model for shipment-request.
type ShipmentRequest struct {
	// CarrierAccount Carrier account chosen for the shipment. Should contain either the carrier account id or carrier account name. Carrier account id takes precedence if both fields are passed.
	CarrierAccount *CarrierAccountRequest `json:"carrier_account,omitempty"`

	// Collection Collection details chosen for the shipment, such as scheduled collection date.
	//
	// It can be set using one of the following options
	//
	// Option 1: Provide the `scheduled_from` and `scheduled_to` to choose the scheduled date along with start and end time.
	//
	// Example:
	// "collection": {
	//   "scheduled_from": "2022-01-01'T'10:00:00.000+1:00",
	//   "scheduled_to": "2022-01-01'T'12:00:00.000+1:00"
	// }
	//
	// Option 2: Provide the `scheduled_date` only to choose the entire day.
	//
	// Example:
	// "collection": {
	//   "scheduled_date": "2022-01-01"
	// }
	Collection *CollectionRequest `json:"collection,omitempty"`

	// CustomAttributes Custom attributes in the form of a map:
	// ```
	// {"attribute1" : ["value1", "value2"], "attribute2" : ["value1", "value2"]}
	// ```
	// Please Note: You can only use custom attributes if you are subscribed to this feature.
	CustomAttributes *CustomAttributes `json:"custom_attributes,omitempty"`

	// Customs Customs declaration details such as total declared value.
	Customs *CustomsObject `json:"customs,omitempty"`

	// Delivery The delivery options chosen for the shipment, including the delivery type and schedule.
	//
	// It can be set using one of the following options
	//
	// Option 1: Provide the `scheduled_from` and `scheduled_to` to choose the scheduled date along with start and end time.
	//
	// Example:
	// "delivery": {
	//   "delivery_type": "STANDARD",
	//   "scheduled_from": "2022-01-01'T'10:00:00.000+1:00",
	//   "scheduled_to": "2022-01-01'T'12:00:00.000+1:00"
	// }
	//
	// Option 2: Provide the `scheduled_date` only to choose the entire day.
	//
	// Example:
	// "delivery": {
	//   "delivery_type": "STANDARD",
	//   "scheduled_date": "2022-01-01"
	// }
	Delivery *DeliveryRequest `json:"delivery,omitempty"`

	// Dropoff Dropoff address for the shipment. You can either pass a free-form address or a predefined location.
	//
	// For forward shipments, you can pass the customer's dropoff address as a free-form address.
	//
	// For reverse shipments, you must pass a predefined dropoff location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
	Dropoff    ShipmentRequest_Dropoff    `json:"dropoff"`
	EntityType *ShipmentRequestEntityType `json:"entity_type,omitempty"`

	// Freight List of packages of type pallet or carton in a B2B shipment.
	Freight *struct {
		Packages *[]PackageObject `json:"packages,omitempty"`
	} `json:"freight,omitempty"`

	// Items List of individual items or SKUs in a shipment.
	Items []ItemRequest `json:"items"`

	// Language Two letter ISO 639-1 code. Example: en
	Language *string `json:"language,omitempty"`

	// Merchant Merchant ID is mandatory to create a shipment
	Merchant string `json:"merchant"`

	// OrderDate Date-time in ISO 8601 format.
	//
	// Example: 2020-09-03T17:07:05.000+1:00 represents the date-time in UTC+1 time zone or 2020-09-03T17:07:05.000Z represents date-time in UTC (zulu) time zone
	OrderDate *time.Time `json:"order_date,omitempty"`

	// OrderType Pass one of the order types you have predefined in Carriyo
	OrderType *string `json:"order_type,omitempty"`

	// Parcels List of parcels in a B2C shipment.
	Parcels *[]ParcelRequest `json:"parcels,omitempty"`

	// Payment Payment details including the total value of the shipment and any pending Cash on Delivery amount.
	Payment PaymentRequest `json:"payment"`

	// Pickup Pickup address for the shipment. You can either pass a free-form address or a predefined location.
	//
	// For forward shipments, you must pass a predefined pickup location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
	//
	// For reverse shipments, you can pass the customer's pickup address as a free-form pickup address.
	Pickup ShipmentRequest_Pickup `json:"pickup"`

	// References References for a shipment, provided by the merchant.
	//
	// The `partner_order_reference` is mandatory but not required to be unique. It is usually the customer facing order number.
	//
	// The `partner_shipment_reference` must be unique for every shipment. It is mandatory, but is copied from `partner_order_reference` if it is not provided.
	//
	// If a single order has multiple shipments, then they will share the `partner_order_reference` but have unique `partner_shipment_reference`.
	References ReferencesRequest `json:"references"`
}

// ShipmentRequest_Dropoff Dropoff address for the shipment. You can either pass a free-form address or a predefined location.
//
// For forward shipments, you can pass the customer's dropoff address as a free-form address.
//
// For reverse shipments, you must pass a predefined dropoff location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
type ShipmentRequest_Dropoff struct {
	union json.RawMessage
}

// ShipmentRequestEntityType defines model for ShipmentRequest.EntityType.
type ShipmentRequestEntityType string

// ShipmentRequest_Pickup Pickup address for the shipment. You can either pass a free-form address or a predefined location.
//
// For forward shipments, you must pass a predefined pickup location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
//
// For reverse shipments, you can pass the customer's pickup address as a free-form pickup address.
type ShipmentRequest_Pickup struct {
	union json.RawMessage
}

// ShippingRate Shipping Rate based on either the costing profile you have configured for the carrier or carrier costing api response
type ShippingRate struct {
	Carrier            *string        `json:"carrier,omitempty"`
	CarrierAccountId   *string        `json:"carrier_account_id,omitempty"`
	CarrierAccountName *string        `json:"carrier_account_name,omitempty"`
	DeliveryPromise    *string        `json:"delivery_promise,omitempty"`
	ErrorDetails       *[]ErrorDetail `json:"error_details,omitempty"`
	EstimatedDays      *int           `json:"estimated_days,omitempty"`

	// EstimatedShippingCost The estimated cost of the shipping based either on the costing profile you have configured for the carrier or carrier costing API response
	EstimatedShippingCost *EstimatedShippingCost `json:"estimated_shipping_cost,omitempty"`
	ServiceDescription    *string                `json:"service_description,omitempty"`
	ServiceName           *string                `json:"service_name,omitempty"`
}

// ShippingRateItemRequest defines model for shipping-rate-item-request.
type ShippingRateItemRequest struct {
	// Cost The unit cost of the item
	Cost *struct {
		Amount float32 `json:"amount"`

		// Currency The three-letter currency code (ISO 4217) for the amount. e.g., USD
		Currency string `json:"currency"`
	} `json:"cost,omitempty"`

	// DangerousGoods If the item is classified as dangerous goods. Usually required for cross-border shipping.
	DangerousGoods *bool `json:"dangerous_goods,omitempty"`

	// HsCode HS Code of the item. Usually required for cross-border shipping.
	HsCode *string `json:"hs_code,omitempty"`

	// OriginCountry Country of origin of the item. Usually required for cross-border shipping.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Price The unit price of the item
	Price *struct {
		Amount float32 `json:"amount"`

		// Currency The three-letter currency code (ISO 4217) for the amount. e.g., USD
		Currency string `json:"currency"`
	} `json:"price,omitempty"`
	Quantity *int `json:"quantity,omitempty"`

	// Sku SKU ID of the item. Only required when you are passing parcel_items in the parcel.
	Sku *string `json:"sku,omitempty"`

	// Weight The weight of the item
	Weight *struct {
		// Unit Default weight unit is `kg` if not provided.
		Unit  *ShippingRateItemRequestWeightUnit `json:"unit,omitempty"`
		Value *float32                           `json:"value,omitempty"`
	} `json:"weight,omitempty"`
}

// ShippingRateItemRequestWeightUnit Default weight unit is `kg` if not provided.
type ShippingRateItemRequestWeightUnit string

// ShippingRateLocationRequest Provide geography information
type ShippingRateLocationRequest struct {
	// Area District, suburb or neighbourhood, represented by the Carriyo Area Code if known. If not, it's a free text.
	//
	// Please use the Carriyo standard Area Code when available, to ensure that Carriyo can map this information correctly to the carrier.
	//
	// [Please refer to the Carriyo Geo List for more information.](/guides/carriyo-geo-list)
	Area *string `json:"area,omitempty"`

	// City City, town, or village, represented by the Carriyo City Code if known. If not, it's a free text.
	//
	// Please use the Carriyo standard City Code when available, to ensure that Carriyo can map this information correctly to the carrier.
	//
	// [Please refer to the Carriyo Geo List for more information.](/guides/carriyo-geo-list)
	City string `json:"city"`

	// Coords Latitude and longitude (decimal degrees) of the address as an array. e.g., [25.19741, 55.27442]
	Coords *[]float32 `json:"coords,omitempty"`

	// Country Two-letter country code (ISO 3166-1 alpha-2).
	Country string `json:"country"`

	// Postcode ZIP or postal code
	Postcode *string `json:"postcode,omitempty"`

	// State State, county, province, or region, represented by the Carriyo State Code if known. If not, it's a free text.
	//
	// **Note: The state is automatically set if a standard Carriyo city is passed.**
	//
	// [Please refer to the Carriyo Geo List for more information.](/guides/carriyo-geo-list)
	State *string `json:"state,omitempty"`
}

// ShippingRatePackageObject List of packages of type pallet or carton in a B2B shipment.
type ShippingRatePackageObject struct {
	Dimension *Dimension   `json:"dimension,omitempty"`
	Type      *interface{} `json:"type,omitempty"`
	Weight    *Weight      `json:"weight,omitempty"`
}

// ShippingRateParcelRequest List of parcels in a B2C shipment.
type ShippingRateParcelRequest struct {
	Dimension   *Dimension    `json:"dimension,omitempty"`
	ParcelItems *[]ParcelItem `json:"parcel_items,omitempty"`
	Weight      *Weight       `json:"weight,omitempty"`
}

// ShippingRatesRequest This endpoint will return shipping rates based on either costing profile for that particular carrier or getting rates from the carrier real time.
type ShippingRatesRequest struct {
	// CarrierAccounts List of carrier accounts for which shipping rate is requested.
	CarrierAccounts *[]CarrierAccountRequest `json:"carrier_accounts,omitempty"`

	// Collection Collection details chosen for the shipment, such as scheduled collection date.
	Collection *CollectionObject `json:"collection,omitempty"`

	// CustomAttributes Custom attributes in the form of a map:
	// ```
	// {"attribute1" : ["value1", "value2"], "attribute2" : ["value1", "value2"]}
	// ```
	// Please Note: You can only use custom attributes if you are subscribed to this feature.
	CustomAttributes *CustomAttributes `json:"custom_attributes,omitempty"`

	// Customs Customs declaration details such as total declared value.
	Customs *CustomsObject `json:"customs,omitempty"`

	// Delivery Delivery details chosen for the shipment, such as chosen delivery type and scheduled delivery date.
	Delivery *DeliveryObject `json:"delivery,omitempty"`

	// Dropoff Dropoff address for the shipment. You can either pass a free-form address or a predefined location.
	//
	// For forward shipments, you can pass the customer's dropoff address as a free-form address.
	//
	// For reverse shipments, you must pass a predefined dropoff location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
	Dropoff    ShippingRatesRequest_Dropoff    `json:"dropoff"`
	EntityType *ShippingRatesRequestEntityType `json:"entity_type,omitempty"`

	// Freight (One of parcels or freight required) List of packages of type pallet or carton in a B2B shipment.
	Freight *struct {
		Packages *[]ShippingRatePackageObject `json:"packages,omitempty"`
	} `json:"freight,omitempty"`

	// Items List of individual items or SKUs in a shipment.
	Items *[]ShippingRateItemRequest `json:"items,omitempty"`

	// Merchant ID of the merchant
	Merchant *string `json:"merchant,omitempty"`

	// Parcels (One of parcels or freight required) List of parcels in a B2C shipment.
	Parcels []ShippingRateParcelRequest `json:"parcels"`

	// Payment Payment details including the total value of the shipment and any pending Cash on Delivery amount.
	Payment *PaymentRequest `json:"payment,omitempty"`

	// Pickup Pickup address for the shipment. You can either pass a free-form address or a predefined location.
	//
	// For forward shipments, you must pass a predefined pickup location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
	//
	// For reverse shipments, you can pass the customer's pickup address as a free-form pickup address.
	Pickup ShippingRatesRequest_Pickup `json:"pickup"`
}

// ShippingRatesRequest_Dropoff Dropoff address for the shipment. You can either pass a free-form address or a predefined location.
//
// For forward shipments, you can pass the customer's dropoff address as a free-form address.
//
// For reverse shipments, you must pass a predefined dropoff location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
type ShippingRatesRequest_Dropoff struct {
	union json.RawMessage
}

// ShippingRatesRequestEntityType defines model for ShippingRatesRequest.EntityType.
type ShippingRatesRequestEntityType string

// ShippingRatesRequest_Pickup Pickup address for the shipment. You can either pass a free-form address or a predefined location.
//
// For forward shipments, you must pass a predefined pickup location. Carriyo will copy the contact and address fields from the specified location. To specify the location, you can use Carriyo's internal location ID (`partner_location_id`), or your own location code (`partner_location_code`) as defined when you created the location in Carriyo.
//
// For reverse shipments, you can pass the customer's pickup address as a free-form pickup address.
type ShippingRatesRequest_Pickup struct {
	union json.RawMessage
}

// ShippingRatesResponse The response returned for shipping rates for one or more carriers.
type ShippingRatesResponse struct {
	ShippingRates *[]ShippingRate `json:"shipping_rates,omitempty"`
}

// StatusField defines model for status-field.
type StatusField string

// StringConditionField defines model for string-condition-field.
type StringConditionField struct {
	Operator *StringConditionFieldOperator `json:"operator,omitempty"`
	Value    *[]string                     `json:"value,omitempty"`
}

// StringConditionFieldOperator defines model for StringConditionField.Operator.
type StringConditionFieldOperator string

// UpdateParcelsRequest defines model for update-parcels-request.
type UpdateParcelsRequest struct {
	Parcels *[]ParcelRequest `json:"parcels,omitempty"`
}

// Weight defines model for weight.
type Weight struct {
	// Unit Default weight unit is `kg` if not provided.
	Unit  *WeightUnit `json:"unit,omitempty"`
	Value *float32    `json:"value,omitempty"`
}

// WeightUnit Default weight unit is `kg` if not provided.
type WeightUnit string

// ListAttrbutesParams defines parameters for ListAttrbutes.
type ListAttrbutesParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// CreateAttributeParams defines parameters for CreateAttribute.
type CreateAttributeParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// DeleteAttributeParams defines parameters for DeleteAttribute.
type DeleteAttributeParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// GetAttributeParams defines parameters for GetAttribute.
type GetAttributeParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// UpdateAttributeParams defines parameters for UpdateAttribute.
type UpdateAttributeParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// ListAutomationRulesetsParams defines parameters for ListAutomationRulesets.
type ListAutomationRulesetsParams struct {
	// Merchant merchant id
	Merchant *string `form:"merchant,omitempty" json:"merchant,omitempty"`

	// EntityType Shipment entity type FORWARD or REVERSE
	EntityType  *string `form:"entity-type,omitempty" json:"entity-type,omitempty"`
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// CreateAutomationRulesetAndRulesParams defines parameters for CreateAutomationRulesetAndRules.
type CreateAutomationRulesetAndRulesParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// DeleteAutomationRulesetParams defines parameters for DeleteAutomationRuleset.
type DeleteAutomationRulesetParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// GetAutomationRulesetParams defines parameters for GetAutomationRuleset.
type GetAutomationRulesetParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// PatchAutomationRulesetParams defines parameters for PatchAutomationRuleset.
type PatchAutomationRulesetParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// UpdateAutomationRulesetAndRulesParams defines parameters for UpdateAutomationRulesetAndRules.
type UpdateAutomationRulesetAndRulesParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// ListAutomationRulesParams defines parameters for ListAutomationRules.
type ListAutomationRulesParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// CreateAutomationRulesParams defines parameters for CreateAutomationRules.
type CreateAutomationRulesParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// UpdateAutomationRulesSequenceParams defines parameters for UpdateAutomationRulesSequence.
type UpdateAutomationRulesSequenceParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// DeleteAutomationRuleParams defines parameters for DeleteAutomationRule.
type DeleteAutomationRuleParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// GetAutomationRuleParams defines parameters for GetAutomationRule.
type GetAutomationRuleParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// UpdateAutomationRuleParams defines parameters for UpdateAutomationRule.
type UpdateAutomationRuleParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// ListCarrierAccountsParams defines parameters for ListCarrierAccounts.
type ListCarrierAccountsParams struct {
	Status      *ListCarrierAccountsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
	XApiKey     *string                          `json:"x-api-key,omitempty"`
	TenantId    *string                          `json:"tenant-id,omitempty"`
	ContentType *string                          `json:"Content-Type,omitempty"`
}

// ListCarrierAccountsParamsStatus defines parameters for ListCarrierAccounts.
type ListCarrierAccountsParamsStatus string

// CreateCarrierAccountParams defines parameters for CreateCarrierAccount.
type CreateCarrierAccountParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// DeleteCarrierAccountParams defines parameters for DeleteCarrierAccount.
type DeleteCarrierAccountParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// GetCarrierAccountParams defines parameters for GetCarrierAccount.
type GetCarrierAccountParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// UpdateCarrierAccountParams defines parameters for UpdateCarrierAccount.
type UpdateCarrierAccountParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// GetShippingRatesParams defines parameters for GetShippingRates.
type GetShippingRatesParams struct {
	XApiKey  string `json:"x-api-key"`
	TenantId string `json:"tenant-id"`
}

// ListManifestsParams defines parameters for ListManifests.
type ListManifestsParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// CreateManifestParams defines parameters for CreateManifest.
type CreateManifestParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// DeleteManifestParams defines parameters for DeleteManifest.
type DeleteManifestParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// GetManifestParams defines parameters for GetManifest.
type GetManifestParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// CancelManifestParams defines parameters for CancelManifest.
type CancelManifestParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// RetryManifestParams defines parameters for RetryManifest.
type RetryManifestParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// ShipManifestParams defines parameters for ShipManifest.
type ShipManifestParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// ListServiceLevelRulesetsParams defines parameters for ListServiceLevelRulesets.
type ListServiceLevelRulesetsParams struct {
	// Merchant merchant id
	Merchant *string `form:"merchant,omitempty" json:"merchant,omitempty"`

	// EntityType Shipment entity type FORWARD or REVERSE
	EntityType  *string `form:"entity-type,omitempty" json:"entity-type,omitempty"`
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// CreateServiceLevelRulesetAndRulesParams defines parameters for CreateServiceLevelRulesetAndRules.
type CreateServiceLevelRulesetAndRulesParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// UpdateServiceLevelRulesSequenceParams defines parameters for UpdateServiceLevelRulesSequence.
type UpdateServiceLevelRulesSequenceParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// DeleteServiceLevelRuleParams defines parameters for DeleteServiceLevelRule.
type DeleteServiceLevelRuleParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// GetServiceLevelRuleParams defines parameters for GetServiceLevelRule.
type GetServiceLevelRuleParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// UpdateServiceLevelRuleParams defines parameters for UpdateServiceLevelRule.
type UpdateServiceLevelRuleParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// DeleteServiceLevelRulesetParams defines parameters for DeleteServiceLevelRuleset.
type DeleteServiceLevelRulesetParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// GetServiceLevelRulesetParams defines parameters for GetServiceLevelRuleset.
type GetServiceLevelRulesetParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// PatchServiceLevelRulesetParams defines parameters for PatchServiceLevelRuleset.
type PatchServiceLevelRulesetParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// UpdateServiceLevelRulesetAndRulesParams defines parameters for UpdateServiceLevelRulesetAndRules.
type UpdateServiceLevelRulesetAndRulesParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// ListServiceLevelRulesParams defines parameters for ListServiceLevelRules.
type ListServiceLevelRulesParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// CreateServiceLevelRulesParams defines parameters for CreateServiceLevelRules.
type CreateServiceLevelRulesParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// ListShipmentsParams defines parameters for ListShipments.
type ListShipmentsParams struct {
	// SearchString The search string to find shipments using shipment data such as carrier tracking number, order reference, shipment reference, customer name, email etc.
	SearchString *string `form:"search_string,omitempty" json:"search_string,omitempty"`

	// OrderRef The string to be used to fetch shipments for a given order reference.
	OrderRef *string `form:"order_ref,omitempty" json:"order_ref,omitempty"`

	// Merchant The merchant parameter filters shipments for a given merchant. This parameter can be used multiple times to filter results for multiple merchants.
	Merchant *string `form:"merchant,omitempty" json:"merchant,omitempty"`

	// ShipmentType The shipment type can either be `forward` or `reverse`. If not passed, then both types of shipments will be included in the results.
	ShipmentType *string `form:"shipment_type,omitempty" json:"shipment_type,omitempty"`

	// CreationDateFrom The start date in ISO 8601 format to filter the results using shipment creation date.
	CreationDateFrom *string `form:"creation_date_from,omitempty" json:"creation_date_from,omitempty"`

	// CreationDateTo The end date in ISO 8601 format to filter the results using shipment creation date.
	CreationDateTo *string `form:"creation_date_to,omitempty" json:"creation_date_to,omitempty"`

	// UpdateDateFrom The start date in ISO 8601 format to filter results, returning shipments that were either created OR updated during this time period.
	UpdateDateFrom *string `form:"update_date_from,omitempty" json:"update_date_from,omitempty"`

	// UpdateDateTo The end date in ISO 8601 format to filter results, returning shipments that were either created OR updated during this time period.
	UpdateDateTo *string `form:"update_date_to,omitempty" json:"update_date_to,omitempty"`

	// Page The page number of the result set, starting from 0. Defaults to the first page (page 0).
	Page *string `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of results to be included in the response, ranging from 10 to 100. Defaults to page size of 10.
	PageSize *string `form:"page_size,omitempty" json:"page_size,omitempty"`
	XApiKey  string  `json:"x-api-key"`
	TenantId string  `json:"tenant-id"`
}

// CreateShipmentJSONBody defines parameters for CreateShipment.
type CreateShipmentJSONBody struct {
	union json.RawMessage
}

// CreateShipmentParams defines parameters for CreateShipment.
type CreateShipmentParams struct {
	// Draft Pass true for draft shipment
	Draft       *bool  `form:"draft,omitempty" json:"draft,omitempty"`
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// GetBulkStatusParams defines parameters for GetBulkStatus.
type GetBulkStatusParams struct {
	ShipmentId *[]string `form:"shipment_id,omitempty" json:"shipment_id,omitempty"`
	XApiKey    *string   `json:"x-api-key,omitempty"`
	TenantId   *string   `json:"tenant-id,omitempty"`
}

// GetShipmentParams defines parameters for GetShipment.
type GetShipmentParams struct {
	XApiKey  string `json:"x-api-key"`
	TenantId string `json:"tenant-id"`
}

// UpdateShipmentPatchParams defines parameters for UpdateShipmentPatch.
type UpdateShipmentPatchParams struct {
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// UpdateShipmentParams defines parameters for UpdateShipment.
type UpdateShipmentParams struct {
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// CancelShipmentJSONBody defines parameters for CancelShipment.
type CancelShipmentJSONBody struct {
	// UpdateReasonCode Any one of the standard reason codes (below) or custom reason codes defined by the merchant.
	//
	// [Click here for the list of Standard Reason Codes](/guides/shipment-reason-codes/)
	UpdateReasonCode *string `json:"update_reason_code,omitempty"`
}

// CancelShipmentParams defines parameters for CancelShipment.
type CancelShipmentParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// ConfirmShipmentParams defines parameters for ConfirmShipment.
type ConfirmShipmentParams struct {
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// EstimateShippingCostForShipmentParams defines parameters for EstimateShippingCostForShipment.
type EstimateShippingCostForShipmentParams struct {
	XApiKey  string `json:"x-api-key"`
	TenantId string `json:"tenant-id"`
}

// RefreshLabelParams defines parameters for RefreshLabel.
type RefreshLabelParams struct {
	XApiKey  string `json:"x-api-key"`
	TenantId string `json:"tenant-id"`
}

// UpdateParcelsParams defines parameters for UpdateParcels.
type UpdateParcelsParams struct {
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// ReadyToShipParams defines parameters for ReadyToShip.
type ReadyToShipParams struct {
	XApiKey  string `json:"x-api-key"`
	TenantId string `json:"tenant-id"`
}

// ReassignShipmentJSONBody defines parameters for ReassignShipment.
type ReassignShipmentJSONBody struct {
	// CarrierAccount Carrier account chosen for the shipment. Should contain either the carrier account id or carrier account name. Carrier account id takes precedence if both fields are passed.
	CarrierAccount *CarrierAccountRequest `json:"carrier_account,omitempty"`
}

// ReassignShipmentParams defines parameters for ReassignShipment.
type ReassignShipmentParams struct {
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// ReprocessShipmentParams defines parameters for ReprocessShipment.
type ReprocessShipmentParams struct {
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// UpdateCollectionScheduleParams defines parameters for UpdateCollectionSchedule.
type UpdateCollectionScheduleParams struct {
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// UpdateDeliveryPromiseParams defines parameters for UpdateDeliveryPromise.
type UpdateDeliveryPromiseParams struct {
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// UpdateDeliveryScheduleParams defines parameters for UpdateDeliverySchedule.
type UpdateDeliveryScheduleParams struct {
	XApiKey     string `json:"x-api-key"`
	TenantId    string `json:"tenant-id"`
	ContentType string `json:"Content-Type"`
}

// UpdateStatusJSONBody defines parameters for UpdateStatus.
type UpdateStatusJSONBody struct {
	NewStatus  *string `json:"new_status,omitempty"`
	UpdateDate *string `json:"update_date,omitempty"`
}

// UpdateStatusParams defines parameters for UpdateStatus.
type UpdateStatusParams struct {
	XApiKey     *string `json:"x-api-key,omitempty"`
	TenantId    *string `json:"tenant-id,omitempty"`
	ContentType *string `json:"Content-Type,omitempty"`
}

// CreateAttributeJSONRequestBody defines body for CreateAttribute for application/json ContentType.
type CreateAttributeJSONRequestBody = AttributeRequest

// UpdateAttributeJSONRequestBody defines body for UpdateAttribute for application/json ContentType.
type UpdateAttributeJSONRequestBody = AttributeRequest

// CreateAutomationRulesetAndRulesJSONRequestBody defines body for CreateAutomationRulesetAndRules for application/json ContentType.
type CreateAutomationRulesetAndRulesJSONRequestBody = AutomationRulesetWithRulesRequest

// PatchAutomationRulesetJSONRequestBody defines body for PatchAutomationRuleset for application/json ContentType.
type PatchAutomationRulesetJSONRequestBody = RulesetRequest

// UpdateAutomationRulesetAndRulesJSONRequestBody defines body for UpdateAutomationRulesetAndRules for application/json ContentType.
type UpdateAutomationRulesetAndRulesJSONRequestBody = AutomationRulesetWithRulesRequest

// CreateAutomationRulesJSONRequestBody defines body for CreateAutomationRules for application/json ContentType.
type CreateAutomationRulesJSONRequestBody = AutomationRuleRequest

// UpdateAutomationRulesSequenceJSONRequestBody defines body for UpdateAutomationRulesSequence for application/json ContentType.
type UpdateAutomationRulesSequenceJSONRequestBody = SequencesRequest

// UpdateAutomationRuleJSONRequestBody defines body for UpdateAutomationRule for application/json ContentType.
type UpdateAutomationRuleJSONRequestBody = AutomationRuleRequest

// CreateCarrierAccountJSONRequestBody defines body for CreateCarrierAccount for application/json ContentType.
type CreateCarrierAccountJSONRequestBody = CarrierAccountEndpointRequest

// UpdateCarrierAccountJSONRequestBody defines body for UpdateCarrierAccount for application/json ContentType.
type UpdateCarrierAccountJSONRequestBody = CarrierAccountEndpointRequest

// GetShippingRatesJSONRequestBody defines body for GetShippingRates for application/json ContentType.
type GetShippingRatesJSONRequestBody = ShippingRatesRequest

// CreateManifestJSONRequestBody defines body for CreateManifest for application/json ContentType.
type CreateManifestJSONRequestBody = ManifestRequest

// CreateServiceLevelRulesetAndRulesJSONRequestBody defines body for CreateServiceLevelRulesetAndRules for application/json ContentType.
type CreateServiceLevelRulesetAndRulesJSONRequestBody = ServiceLevelRulesetWithRulesRequest

// UpdateServiceLevelRulesSequenceJSONRequestBody defines body for UpdateServiceLevelRulesSequence for application/json ContentType.
type UpdateServiceLevelRulesSequenceJSONRequestBody = SequencesRequest

// UpdateServiceLevelRuleJSONRequestBody defines body for UpdateServiceLevelRule for application/json ContentType.
type UpdateServiceLevelRuleJSONRequestBody = ServiceLevelRuleRequest

// PatchServiceLevelRulesetJSONRequestBody defines body for PatchServiceLevelRuleset for application/json ContentType.
type PatchServiceLevelRulesetJSONRequestBody = RulesetRequest

// UpdateServiceLevelRulesetAndRulesJSONRequestBody defines body for UpdateServiceLevelRulesetAndRules for application/json ContentType.
type UpdateServiceLevelRulesetAndRulesJSONRequestBody = ServiceLevelRulesetWithRulesRequest

// CreateServiceLevelRulesJSONRequestBody defines body for CreateServiceLevelRules for application/json ContentType.
type CreateServiceLevelRulesJSONRequestBody = ServiceLevelRuleRequest

// CreateShipmentJSONRequestBody defines body for CreateShipment for application/json ContentType.
type CreateShipmentJSONRequestBody CreateShipmentJSONBody

// UpdateShipmentPatchJSONRequestBody defines body for UpdateShipmentPatch for application/json ContentType.
type UpdateShipmentPatchJSONRequestBody = ShipmentDraftRequest

// UpdateShipmentJSONRequestBody defines body for UpdateShipment for application/json ContentType.
type UpdateShipmentJSONRequestBody = ShipmentDraftRequest

// CancelShipmentJSONRequestBody defines body for CancelShipment for application/json ContentType.
type CancelShipmentJSONRequestBody CancelShipmentJSONBody

// ConfirmShipmentJSONRequestBody defines body for ConfirmShipment for application/json ContentType.
type ConfirmShipmentJSONRequestBody = ShipmentPatchRequest

// UpdateParcelsJSONRequestBody defines body for UpdateParcels for application/json ContentType.
type UpdateParcelsJSONRequestBody = UpdateParcelsRequest

// ReadyToShipJSONRequestBody defines body for ReadyToShip for application/json ContentType.
type ReadyToShipJSONRequestBody = UpdateParcelsRequest

// ReassignShipmentJSONRequestBody defines body for ReassignShipment for application/json ContentType.
type ReassignShipmentJSONRequestBody ReassignShipmentJSONBody

// ReprocessShipmentJSONRequestBody defines body for ReprocessShipment for application/json ContentType.
type ReprocessShipmentJSONRequestBody = ShipmentPatchRequest

// UpdateCollectionScheduleJSONRequestBody defines body for UpdateCollectionSchedule for application/json ContentType.
type UpdateCollectionScheduleJSONRequestBody = CollectionRequest

// UpdateDeliveryPromiseJSONRequestBody defines body for UpdateDeliveryPromise for application/json ContentType.
type UpdateDeliveryPromiseJSONRequestBody = PromisedDeliveryDateRequest

// UpdateDeliveryScheduleJSONRequestBody defines body for UpdateDeliverySchedule for application/json ContentType.
type UpdateDeliveryScheduleJSONRequestBody = CollectionRequest

// UpdateStatusJSONRequestBody defines body for UpdateStatus for application/json ContentType.
type UpdateStatusJSONRequestBody UpdateStatusJSONBody

// AsFreeFormRequest returns the union data inside the ShipmentDraftRequest_Dropoff as a FreeFormRequest
func (t ShipmentDraftRequest_Dropoff) AsFreeFormRequest() (FreeFormRequest, error) {
	var body FreeFormRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeFormRequest overwrites any union data inside the ShipmentDraftRequest_Dropoff as the provided FreeFormRequest
func (t *ShipmentDraftRequest_Dropoff) FromFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeFormRequest performs a merge with any union data inside the ShipmentDraftRequest_Dropoff, using the provided FreeFormRequest
func (t *ShipmentDraftRequest_Dropoff) MergeFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocationRequest returns the union data inside the ShipmentDraftRequest_Dropoff as a LocationRequest
func (t ShipmentDraftRequest_Dropoff) AsLocationRequest() (LocationRequest, error) {
	var body LocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationRequest overwrites any union data inside the ShipmentDraftRequest_Dropoff as the provided LocationRequest
func (t *ShipmentDraftRequest_Dropoff) FromLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationRequest performs a merge with any union data inside the ShipmentDraftRequest_Dropoff, using the provided LocationRequest
func (t *ShipmentDraftRequest_Dropoff) MergeLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ShipmentDraftRequest_Dropoff) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ShipmentDraftRequest_Dropoff) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocationRequest returns the union data inside the ShipmentDraftRequest_Pickup as a LocationRequest
func (t ShipmentDraftRequest_Pickup) AsLocationRequest() (LocationRequest, error) {
	var body LocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationRequest overwrites any union data inside the ShipmentDraftRequest_Pickup as the provided LocationRequest
func (t *ShipmentDraftRequest_Pickup) FromLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationRequest performs a merge with any union data inside the ShipmentDraftRequest_Pickup, using the provided LocationRequest
func (t *ShipmentDraftRequest_Pickup) MergeLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFreeFormRequest returns the union data inside the ShipmentDraftRequest_Pickup as a FreeFormRequest
func (t ShipmentDraftRequest_Pickup) AsFreeFormRequest() (FreeFormRequest, error) {
	var body FreeFormRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeFormRequest overwrites any union data inside the ShipmentDraftRequest_Pickup as the provided FreeFormRequest
func (t *ShipmentDraftRequest_Pickup) FromFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeFormRequest performs a merge with any union data inside the ShipmentDraftRequest_Pickup, using the provided FreeFormRequest
func (t *ShipmentDraftRequest_Pickup) MergeFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ShipmentDraftRequest_Pickup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ShipmentDraftRequest_Pickup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFreeFormRequest returns the union data inside the ShipmentPatchRequest_Dropoff as a FreeFormRequest
func (t ShipmentPatchRequest_Dropoff) AsFreeFormRequest() (FreeFormRequest, error) {
	var body FreeFormRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeFormRequest overwrites any union data inside the ShipmentPatchRequest_Dropoff as the provided FreeFormRequest
func (t *ShipmentPatchRequest_Dropoff) FromFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeFormRequest performs a merge with any union data inside the ShipmentPatchRequest_Dropoff, using the provided FreeFormRequest
func (t *ShipmentPatchRequest_Dropoff) MergeFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocationRequest returns the union data inside the ShipmentPatchRequest_Dropoff as a LocationRequest
func (t ShipmentPatchRequest_Dropoff) AsLocationRequest() (LocationRequest, error) {
	var body LocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationRequest overwrites any union data inside the ShipmentPatchRequest_Dropoff as the provided LocationRequest
func (t *ShipmentPatchRequest_Dropoff) FromLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationRequest performs a merge with any union data inside the ShipmentPatchRequest_Dropoff, using the provided LocationRequest
func (t *ShipmentPatchRequest_Dropoff) MergeLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ShipmentPatchRequest_Dropoff) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ShipmentPatchRequest_Dropoff) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocationRequest returns the union data inside the ShipmentPatchRequest_Pickup as a LocationRequest
func (t ShipmentPatchRequest_Pickup) AsLocationRequest() (LocationRequest, error) {
	var body LocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationRequest overwrites any union data inside the ShipmentPatchRequest_Pickup as the provided LocationRequest
func (t *ShipmentPatchRequest_Pickup) FromLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationRequest performs a merge with any union data inside the ShipmentPatchRequest_Pickup, using the provided LocationRequest
func (t *ShipmentPatchRequest_Pickup) MergeLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFreeFormRequest returns the union data inside the ShipmentPatchRequest_Pickup as a FreeFormRequest
func (t ShipmentPatchRequest_Pickup) AsFreeFormRequest() (FreeFormRequest, error) {
	var body FreeFormRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeFormRequest overwrites any union data inside the ShipmentPatchRequest_Pickup as the provided FreeFormRequest
func (t *ShipmentPatchRequest_Pickup) FromFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeFormRequest performs a merge with any union data inside the ShipmentPatchRequest_Pickup, using the provided FreeFormRequest
func (t *ShipmentPatchRequest_Pickup) MergeFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ShipmentPatchRequest_Pickup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ShipmentPatchRequest_Pickup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFreeFormRequest returns the union data inside the ShipmentRequest_Dropoff as a FreeFormRequest
func (t ShipmentRequest_Dropoff) AsFreeFormRequest() (FreeFormRequest, error) {
	var body FreeFormRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeFormRequest overwrites any union data inside the ShipmentRequest_Dropoff as the provided FreeFormRequest
func (t *ShipmentRequest_Dropoff) FromFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeFormRequest performs a merge with any union data inside the ShipmentRequest_Dropoff, using the provided FreeFormRequest
func (t *ShipmentRequest_Dropoff) MergeFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocationRequest returns the union data inside the ShipmentRequest_Dropoff as a LocationRequest
func (t ShipmentRequest_Dropoff) AsLocationRequest() (LocationRequest, error) {
	var body LocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationRequest overwrites any union data inside the ShipmentRequest_Dropoff as the provided LocationRequest
func (t *ShipmentRequest_Dropoff) FromLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationRequest performs a merge with any union data inside the ShipmentRequest_Dropoff, using the provided LocationRequest
func (t *ShipmentRequest_Dropoff) MergeLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ShipmentRequest_Dropoff) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ShipmentRequest_Dropoff) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocationRequest returns the union data inside the ShipmentRequest_Pickup as a LocationRequest
func (t ShipmentRequest_Pickup) AsLocationRequest() (LocationRequest, error) {
	var body LocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationRequest overwrites any union data inside the ShipmentRequest_Pickup as the provided LocationRequest
func (t *ShipmentRequest_Pickup) FromLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationRequest performs a merge with any union data inside the ShipmentRequest_Pickup, using the provided LocationRequest
func (t *ShipmentRequest_Pickup) MergeLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFreeFormRequest returns the union data inside the ShipmentRequest_Pickup as a FreeFormRequest
func (t ShipmentRequest_Pickup) AsFreeFormRequest() (FreeFormRequest, error) {
	var body FreeFormRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFreeFormRequest overwrites any union data inside the ShipmentRequest_Pickup as the provided FreeFormRequest
func (t *ShipmentRequest_Pickup) FromFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFreeFormRequest performs a merge with any union data inside the ShipmentRequest_Pickup, using the provided FreeFormRequest
func (t *ShipmentRequest_Pickup) MergeFreeFormRequest(v FreeFormRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ShipmentRequest_Pickup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ShipmentRequest_Pickup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsShippingRateLocationRequest returns the union data inside the ShippingRatesRequest_Dropoff as a ShippingRateLocationRequest
func (t ShippingRatesRequest_Dropoff) AsShippingRateLocationRequest() (ShippingRateLocationRequest, error) {
	var body ShippingRateLocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromShippingRateLocationRequest overwrites any union data inside the ShippingRatesRequest_Dropoff as the provided ShippingRateLocationRequest
func (t *ShippingRatesRequest_Dropoff) FromShippingRateLocationRequest(v ShippingRateLocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeShippingRateLocationRequest performs a merge with any union data inside the ShippingRatesRequest_Dropoff, using the provided ShippingRateLocationRequest
func (t *ShippingRatesRequest_Dropoff) MergeShippingRateLocationRequest(v ShippingRateLocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocationRequest returns the union data inside the ShippingRatesRequest_Dropoff as a LocationRequest
func (t ShippingRatesRequest_Dropoff) AsLocationRequest() (LocationRequest, error) {
	var body LocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationRequest overwrites any union data inside the ShippingRatesRequest_Dropoff as the provided LocationRequest
func (t *ShippingRatesRequest_Dropoff) FromLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationRequest performs a merge with any union data inside the ShippingRatesRequest_Dropoff, using the provided LocationRequest
func (t *ShippingRatesRequest_Dropoff) MergeLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ShippingRatesRequest_Dropoff) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ShippingRatesRequest_Dropoff) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocationRequest returns the union data inside the ShippingRatesRequest_Pickup as a LocationRequest
func (t ShippingRatesRequest_Pickup) AsLocationRequest() (LocationRequest, error) {
	var body LocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocationRequest overwrites any union data inside the ShippingRatesRequest_Pickup as the provided LocationRequest
func (t *ShippingRatesRequest_Pickup) FromLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocationRequest performs a merge with any union data inside the ShippingRatesRequest_Pickup, using the provided LocationRequest
func (t *ShippingRatesRequest_Pickup) MergeLocationRequest(v LocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsShippingRateLocationRequest returns the union data inside the ShippingRatesRequest_Pickup as a ShippingRateLocationRequest
func (t ShippingRatesRequest_Pickup) AsShippingRateLocationRequest() (ShippingRateLocationRequest, error) {
	var body ShippingRateLocationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromShippingRateLocationRequest overwrites any union data inside the ShippingRatesRequest_Pickup as the provided ShippingRateLocationRequest
func (t *ShippingRatesRequest_Pickup) FromShippingRateLocationRequest(v ShippingRateLocationRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeShippingRateLocationRequest performs a merge with any union data inside the ShippingRatesRequest_Pickup, using the provided ShippingRateLocationRequest
func (t *ShippingRatesRequest_Pickup) MergeShippingRateLocationRequest(v ShippingRateLocationRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ShippingRatesRequest_Pickup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ShippingRatesRequest_Pickup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAttrbutes request
	ListAttrbutes(ctx context.Context, params *ListAttrbutesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAttributeWithBody request with any body
	CreateAttributeWithBody(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAttribute(ctx context.Context, params *CreateAttributeParams, body CreateAttributeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttribute request
	DeleteAttribute(ctx context.Context, attributeId string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttribute request
	GetAttribute(ctx context.Context, attributeId string, params *GetAttributeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttributeWithBody request with any body
	UpdateAttributeWithBody(ctx context.Context, attributeId string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAttribute(ctx context.Context, attributeId string, params *UpdateAttributeParams, body UpdateAttributeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAutomationRulesets request
	ListAutomationRulesets(ctx context.Context, params *ListAutomationRulesetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAutomationRulesetAndRulesWithBody request with any body
	CreateAutomationRulesetAndRulesWithBody(ctx context.Context, params *CreateAutomationRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAutomationRulesetAndRules(ctx context.Context, params *CreateAutomationRulesetAndRulesParams, body CreateAutomationRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAutomationRuleset request
	DeleteAutomationRuleset(ctx context.Context, automationRulesetId string, params *DeleteAutomationRulesetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutomationRuleset request
	GetAutomationRuleset(ctx context.Context, automationRulesetId string, params *GetAutomationRulesetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAutomationRulesetWithBody request with any body
	PatchAutomationRulesetWithBody(ctx context.Context, automationRulesetId string, params *PatchAutomationRulesetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchAutomationRuleset(ctx context.Context, automationRulesetId string, params *PatchAutomationRulesetParams, body PatchAutomationRulesetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAutomationRulesetAndRulesWithBody request with any body
	UpdateAutomationRulesetAndRulesWithBody(ctx context.Context, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAutomationRulesetAndRules(ctx context.Context, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, body UpdateAutomationRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAutomationRules request
	ListAutomationRules(ctx context.Context, automationRulesetId string, params *ListAutomationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAutomationRulesWithBody request with any body
	CreateAutomationRulesWithBody(ctx context.Context, automationRulesetId string, params *CreateAutomationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAutomationRules(ctx context.Context, automationRulesetId string, params *CreateAutomationRulesParams, body CreateAutomationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAutomationRulesSequenceWithBody request with any body
	UpdateAutomationRulesSequenceWithBody(ctx context.Context, rulesetId string, params *UpdateAutomationRulesSequenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAutomationRulesSequence(ctx context.Context, rulesetId string, params *UpdateAutomationRulesSequenceParams, body UpdateAutomationRulesSequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAutomationRule request
	DeleteAutomationRule(ctx context.Context, rulesetId string, automationRuleId string, params *DeleteAutomationRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutomationRule request
	GetAutomationRule(ctx context.Context, rulesetId string, automationRuleId string, params *GetAutomationRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAutomationRuleWithBody request with any body
	UpdateAutomationRuleWithBody(ctx context.Context, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAutomationRule(ctx context.Context, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, body UpdateAutomationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCarrierAccounts request
	ListCarrierAccounts(ctx context.Context, params *ListCarrierAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCarrierAccountWithBody request with any body
	CreateCarrierAccountWithBody(ctx context.Context, params *CreateCarrierAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCarrierAccount(ctx context.Context, params *CreateCarrierAccountParams, body CreateCarrierAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCarrierAccount request
	DeleteCarrierAccount(ctx context.Context, carrierAccountId string, params *DeleteCarrierAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCarrierAccount request
	GetCarrierAccount(ctx context.Context, carrierAccountId string, params *GetCarrierAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCarrierAccountWithBody request with any body
	UpdateCarrierAccountWithBody(ctx context.Context, carrierAccountId string, params *UpdateCarrierAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCarrierAccount(ctx context.Context, carrierAccountId string, params *UpdateCarrierAccountParams, body UpdateCarrierAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShippingRatesWithBody request with any body
	GetShippingRatesWithBody(ctx context.Context, params *GetShippingRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetShippingRates(ctx context.Context, params *GetShippingRatesParams, body GetShippingRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListManifests request
	ListManifests(ctx context.Context, params *ListManifestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateManifestWithBody request with any body
	CreateManifestWithBody(ctx context.Context, params *CreateManifestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateManifest(ctx context.Context, params *CreateManifestParams, body CreateManifestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteManifest request
	DeleteManifest(ctx context.Context, manifestId string, params *DeleteManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManifest request
	GetManifest(ctx context.Context, manifestId string, params *GetManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelManifest request
	CancelManifest(ctx context.Context, manifestId string, params *CancelManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryManifest request
	RetryManifest(ctx context.Context, manifestId string, params *RetryManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShipManifest request
	ShipManifest(ctx context.Context, manifestId string, params *ShipManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceLevelRulesets request
	ListServiceLevelRulesets(ctx context.Context, params *ListServiceLevelRulesetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceLevelRulesetAndRulesWithBody request with any body
	CreateServiceLevelRulesetAndRulesWithBody(ctx context.Context, params *CreateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceLevelRulesetAndRules(ctx context.Context, params *CreateServiceLevelRulesetAndRulesParams, body CreateServiceLevelRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceLevelRulesSequenceWithBody request with any body
	UpdateServiceLevelRulesSequenceWithBody(ctx context.Context, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceLevelRulesSequence(ctx context.Context, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, body UpdateServiceLevelRulesSequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceLevelRule request
	DeleteServiceLevelRule(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *DeleteServiceLevelRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceLevelRule request
	GetServiceLevelRule(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *GetServiceLevelRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceLevelRuleWithBody request with any body
	UpdateServiceLevelRuleWithBody(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceLevelRule(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, body UpdateServiceLevelRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceLevelRuleset request
	DeleteServiceLevelRuleset(ctx context.Context, serviceLevelRulesetId string, params *DeleteServiceLevelRulesetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceLevelRuleset request
	GetServiceLevelRuleset(ctx context.Context, serviceLevelRulesetId string, params *GetServiceLevelRulesetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchServiceLevelRulesetWithBody request with any body
	PatchServiceLevelRulesetWithBody(ctx context.Context, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchServiceLevelRuleset(ctx context.Context, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, body PatchServiceLevelRulesetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceLevelRulesetAndRulesWithBody request with any body
	UpdateServiceLevelRulesetAndRulesWithBody(ctx context.Context, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceLevelRulesetAndRules(ctx context.Context, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, body UpdateServiceLevelRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceLevelRules request
	ListServiceLevelRules(ctx context.Context, serviceLevelRulesetId string, params *ListServiceLevelRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceLevelRulesWithBody request with any body
	CreateServiceLevelRulesWithBody(ctx context.Context, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceLevelRules(ctx context.Context, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, body CreateServiceLevelRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListShipments request
	ListShipments(ctx context.Context, params *ListShipmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateShipmentWithBody request with any body
	CreateShipmentWithBody(ctx context.Context, params *CreateShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateShipment(ctx context.Context, params *CreateShipmentParams, body CreateShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBulkStatus request
	GetBulkStatus(ctx context.Context, params *GetBulkStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShipment request
	GetShipment(ctx context.Context, shipmentId string, params *GetShipmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateShipmentPatchWithBody request with any body
	UpdateShipmentPatchWithBody(ctx context.Context, shipmentId string, params *UpdateShipmentPatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateShipmentPatch(ctx context.Context, shipmentId string, params *UpdateShipmentPatchParams, body UpdateShipmentPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateShipmentWithBody request with any body
	UpdateShipmentWithBody(ctx context.Context, shipmentId string, params *UpdateShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateShipment(ctx context.Context, shipmentId string, params *UpdateShipmentParams, body UpdateShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelShipmentWithBody request with any body
	CancelShipmentWithBody(ctx context.Context, shipmentId string, params *CancelShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelShipment(ctx context.Context, shipmentId string, params *CancelShipmentParams, body CancelShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmShipmentWithBody request with any body
	ConfirmShipmentWithBody(ctx context.Context, shipmentId string, params *ConfirmShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfirmShipment(ctx context.Context, shipmentId string, params *ConfirmShipmentParams, body ConfirmShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EstimateShippingCostForShipment request
	EstimateShippingCostForShipment(ctx context.Context, shipmentId string, params *EstimateShippingCostForShipmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshLabel request
	RefreshLabel(ctx context.Context, shipmentId string, params *RefreshLabelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateParcelsWithBody request with any body
	UpdateParcelsWithBody(ctx context.Context, shipmentId string, params *UpdateParcelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateParcels(ctx context.Context, shipmentId string, params *UpdateParcelsParams, body UpdateParcelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadyToShipWithBody request with any body
	ReadyToShipWithBody(ctx context.Context, shipmentId string, params *ReadyToShipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadyToShip(ctx context.Context, shipmentId string, params *ReadyToShipParams, body ReadyToShipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReassignShipmentWithBody request with any body
	ReassignShipmentWithBody(ctx context.Context, shipmentId string, params *ReassignShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReassignShipment(ctx context.Context, shipmentId string, params *ReassignShipmentParams, body ReassignShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReprocessShipmentWithBody request with any body
	ReprocessShipmentWithBody(ctx context.Context, shipmentId string, params *ReprocessShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReprocessShipment(ctx context.Context, shipmentId string, params *ReprocessShipmentParams, body ReprocessShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCollectionScheduleWithBody request with any body
	UpdateCollectionScheduleWithBody(ctx context.Context, shipmentId string, params *UpdateCollectionScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCollectionSchedule(ctx context.Context, shipmentId string, params *UpdateCollectionScheduleParams, body UpdateCollectionScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDeliveryPromiseWithBody request with any body
	UpdateDeliveryPromiseWithBody(ctx context.Context, shipmentId string, params *UpdateDeliveryPromiseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDeliveryPromise(ctx context.Context, shipmentId string, params *UpdateDeliveryPromiseParams, body UpdateDeliveryPromiseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDeliveryScheduleWithBody request with any body
	UpdateDeliveryScheduleWithBody(ctx context.Context, shipmentId string, params *UpdateDeliveryScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDeliverySchedule(ctx context.Context, shipmentId string, params *UpdateDeliveryScheduleParams, body UpdateDeliveryScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStatusWithBody request with any body
	UpdateStatusWithBody(ctx context.Context, shipmentId string, params *UpdateStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStatus(ctx context.Context, shipmentId string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAttrbutes(ctx context.Context, params *ListAttrbutesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttrbutesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttributeWithBody(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttributeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttribute(ctx context.Context, params *CreateAttributeParams, body CreateAttributeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttributeRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttribute(ctx context.Context, attributeId string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttributeRequest(c.Server, attributeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttribute(ctx context.Context, attributeId string, params *GetAttributeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttributeRequest(c.Server, attributeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttributeWithBody(ctx context.Context, attributeId string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttributeRequestWithBody(c.Server, attributeId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttribute(ctx context.Context, attributeId string, params *UpdateAttributeParams, body UpdateAttributeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttributeRequest(c.Server, attributeId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAutomationRulesets(ctx context.Context, params *ListAutomationRulesetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAutomationRulesetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAutomationRulesetAndRulesWithBody(ctx context.Context, params *CreateAutomationRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAutomationRulesetAndRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAutomationRulesetAndRules(ctx context.Context, params *CreateAutomationRulesetAndRulesParams, body CreateAutomationRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAutomationRulesetAndRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAutomationRuleset(ctx context.Context, automationRulesetId string, params *DeleteAutomationRulesetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAutomationRulesetRequest(c.Server, automationRulesetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutomationRuleset(ctx context.Context, automationRulesetId string, params *GetAutomationRulesetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutomationRulesetRequest(c.Server, automationRulesetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAutomationRulesetWithBody(ctx context.Context, automationRulesetId string, params *PatchAutomationRulesetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAutomationRulesetRequestWithBody(c.Server, automationRulesetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAutomationRuleset(ctx context.Context, automationRulesetId string, params *PatchAutomationRulesetParams, body PatchAutomationRulesetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAutomationRulesetRequest(c.Server, automationRulesetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationRulesetAndRulesWithBody(ctx context.Context, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationRulesetAndRulesRequestWithBody(c.Server, automationRulesetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationRulesetAndRules(ctx context.Context, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, body UpdateAutomationRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationRulesetAndRulesRequest(c.Server, automationRulesetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAutomationRules(ctx context.Context, automationRulesetId string, params *ListAutomationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAutomationRulesRequest(c.Server, automationRulesetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAutomationRulesWithBody(ctx context.Context, automationRulesetId string, params *CreateAutomationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAutomationRulesRequestWithBody(c.Server, automationRulesetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAutomationRules(ctx context.Context, automationRulesetId string, params *CreateAutomationRulesParams, body CreateAutomationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAutomationRulesRequest(c.Server, automationRulesetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationRulesSequenceWithBody(ctx context.Context, rulesetId string, params *UpdateAutomationRulesSequenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationRulesSequenceRequestWithBody(c.Server, rulesetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationRulesSequence(ctx context.Context, rulesetId string, params *UpdateAutomationRulesSequenceParams, body UpdateAutomationRulesSequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationRulesSequenceRequest(c.Server, rulesetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAutomationRule(ctx context.Context, rulesetId string, automationRuleId string, params *DeleteAutomationRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAutomationRuleRequest(c.Server, rulesetId, automationRuleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutomationRule(ctx context.Context, rulesetId string, automationRuleId string, params *GetAutomationRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutomationRuleRequest(c.Server, rulesetId, automationRuleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationRuleWithBody(ctx context.Context, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationRuleRequestWithBody(c.Server, rulesetId, automationRuleId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationRule(ctx context.Context, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, body UpdateAutomationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationRuleRequest(c.Server, rulesetId, automationRuleId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCarrierAccounts(ctx context.Context, params *ListCarrierAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCarrierAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCarrierAccountWithBody(ctx context.Context, params *CreateCarrierAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCarrierAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCarrierAccount(ctx context.Context, params *CreateCarrierAccountParams, body CreateCarrierAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCarrierAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCarrierAccount(ctx context.Context, carrierAccountId string, params *DeleteCarrierAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCarrierAccountRequest(c.Server, carrierAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCarrierAccount(ctx context.Context, carrierAccountId string, params *GetCarrierAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCarrierAccountRequest(c.Server, carrierAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCarrierAccountWithBody(ctx context.Context, carrierAccountId string, params *UpdateCarrierAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCarrierAccountRequestWithBody(c.Server, carrierAccountId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCarrierAccount(ctx context.Context, carrierAccountId string, params *UpdateCarrierAccountParams, body UpdateCarrierAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCarrierAccountRequest(c.Server, carrierAccountId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingRatesWithBody(ctx context.Context, params *GetShippingRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingRatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingRates(ctx context.Context, params *GetShippingRatesParams, body GetShippingRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingRatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListManifests(ctx context.Context, params *ListManifestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListManifestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManifestWithBody(ctx context.Context, params *CreateManifestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManifestRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManifest(ctx context.Context, params *CreateManifestParams, body CreateManifestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManifestRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManifest(ctx context.Context, manifestId string, params *DeleteManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManifestRequest(c.Server, manifestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManifest(ctx context.Context, manifestId string, params *GetManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManifestRequest(c.Server, manifestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelManifest(ctx context.Context, manifestId string, params *CancelManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelManifestRequest(c.Server, manifestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryManifest(ctx context.Context, manifestId string, params *RetryManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryManifestRequest(c.Server, manifestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShipManifest(ctx context.Context, manifestId string, params *ShipManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShipManifestRequest(c.Server, manifestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceLevelRulesets(ctx context.Context, params *ListServiceLevelRulesetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceLevelRulesetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceLevelRulesetAndRulesWithBody(ctx context.Context, params *CreateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceLevelRulesetAndRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceLevelRulesetAndRules(ctx context.Context, params *CreateServiceLevelRulesetAndRulesParams, body CreateServiceLevelRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceLevelRulesetAndRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceLevelRulesSequenceWithBody(ctx context.Context, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceLevelRulesSequenceRequestWithBody(c.Server, rulesetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceLevelRulesSequence(ctx context.Context, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, body UpdateServiceLevelRulesSequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceLevelRulesSequenceRequest(c.Server, rulesetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceLevelRule(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *DeleteServiceLevelRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceLevelRuleRequest(c.Server, rulesetId, serviceLevelRuleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceLevelRule(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *GetServiceLevelRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceLevelRuleRequest(c.Server, rulesetId, serviceLevelRuleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceLevelRuleWithBody(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceLevelRuleRequestWithBody(c.Server, rulesetId, serviceLevelRuleId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceLevelRule(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, body UpdateServiceLevelRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceLevelRuleRequest(c.Server, rulesetId, serviceLevelRuleId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceLevelRuleset(ctx context.Context, serviceLevelRulesetId string, params *DeleteServiceLevelRulesetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceLevelRulesetRequest(c.Server, serviceLevelRulesetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceLevelRuleset(ctx context.Context, serviceLevelRulesetId string, params *GetServiceLevelRulesetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceLevelRulesetRequest(c.Server, serviceLevelRulesetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchServiceLevelRulesetWithBody(ctx context.Context, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchServiceLevelRulesetRequestWithBody(c.Server, serviceLevelRulesetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchServiceLevelRuleset(ctx context.Context, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, body PatchServiceLevelRulesetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchServiceLevelRulesetRequest(c.Server, serviceLevelRulesetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceLevelRulesetAndRulesWithBody(ctx context.Context, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceLevelRulesetAndRulesRequestWithBody(c.Server, serviceLevelRulesetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceLevelRulesetAndRules(ctx context.Context, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, body UpdateServiceLevelRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceLevelRulesetAndRulesRequest(c.Server, serviceLevelRulesetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceLevelRules(ctx context.Context, serviceLevelRulesetId string, params *ListServiceLevelRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceLevelRulesRequest(c.Server, serviceLevelRulesetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceLevelRulesWithBody(ctx context.Context, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceLevelRulesRequestWithBody(c.Server, serviceLevelRulesetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceLevelRules(ctx context.Context, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, body CreateServiceLevelRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceLevelRulesRequest(c.Server, serviceLevelRulesetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListShipments(ctx context.Context, params *ListShipmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListShipmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateShipmentWithBody(ctx context.Context, params *CreateShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateShipmentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateShipment(ctx context.Context, params *CreateShipmentParams, body CreateShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateShipmentRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBulkStatus(ctx context.Context, params *GetBulkStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBulkStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShipment(ctx context.Context, shipmentId string, params *GetShipmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShipmentRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShipmentPatchWithBody(ctx context.Context, shipmentId string, params *UpdateShipmentPatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShipmentPatchRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShipmentPatch(ctx context.Context, shipmentId string, params *UpdateShipmentPatchParams, body UpdateShipmentPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShipmentPatchRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShipmentWithBody(ctx context.Context, shipmentId string, params *UpdateShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShipmentRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShipment(ctx context.Context, shipmentId string, params *UpdateShipmentParams, body UpdateShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShipmentRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelShipmentWithBody(ctx context.Context, shipmentId string, params *CancelShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelShipmentRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelShipment(ctx context.Context, shipmentId string, params *CancelShipmentParams, body CancelShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelShipmentRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmShipmentWithBody(ctx context.Context, shipmentId string, params *ConfirmShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmShipmentRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmShipment(ctx context.Context, shipmentId string, params *ConfirmShipmentParams, body ConfirmShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmShipmentRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EstimateShippingCostForShipment(ctx context.Context, shipmentId string, params *EstimateShippingCostForShipmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEstimateShippingCostForShipmentRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshLabel(ctx context.Context, shipmentId string, params *RefreshLabelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshLabelRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateParcelsWithBody(ctx context.Context, shipmentId string, params *UpdateParcelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateParcelsRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateParcels(ctx context.Context, shipmentId string, params *UpdateParcelsParams, body UpdateParcelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateParcelsRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadyToShipWithBody(ctx context.Context, shipmentId string, params *ReadyToShipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadyToShipRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadyToShip(ctx context.Context, shipmentId string, params *ReadyToShipParams, body ReadyToShipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadyToShipRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReassignShipmentWithBody(ctx context.Context, shipmentId string, params *ReassignShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReassignShipmentRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReassignShipment(ctx context.Context, shipmentId string, params *ReassignShipmentParams, body ReassignShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReassignShipmentRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReprocessShipmentWithBody(ctx context.Context, shipmentId string, params *ReprocessShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReprocessShipmentRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReprocessShipment(ctx context.Context, shipmentId string, params *ReprocessShipmentParams, body ReprocessShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReprocessShipmentRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollectionScheduleWithBody(ctx context.Context, shipmentId string, params *UpdateCollectionScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionScheduleRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollectionSchedule(ctx context.Context, shipmentId string, params *UpdateCollectionScheduleParams, body UpdateCollectionScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionScheduleRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeliveryPromiseWithBody(ctx context.Context, shipmentId string, params *UpdateDeliveryPromiseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeliveryPromiseRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeliveryPromise(ctx context.Context, shipmentId string, params *UpdateDeliveryPromiseParams, body UpdateDeliveryPromiseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeliveryPromiseRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeliveryScheduleWithBody(ctx context.Context, shipmentId string, params *UpdateDeliveryScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeliveryScheduleRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeliverySchedule(ctx context.Context, shipmentId string, params *UpdateDeliveryScheduleParams, body UpdateDeliveryScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeliveryScheduleRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStatusWithBody(ctx context.Context, shipmentId string, params *UpdateStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStatusRequestWithBody(c.Server, shipmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStatus(ctx context.Context, shipmentId string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStatusRequest(c.Server, shipmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAttrbutesRequest generates requests for ListAttrbutes
func NewListAttrbutesRequest(server string, params *ListAttrbutesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewCreateAttributeRequest calls the generic CreateAttribute builder with application/json body
func NewCreateAttributeRequest(server string, params *CreateAttributeParams, body CreateAttributeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAttributeRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAttributeRequestWithBody generates requests for CreateAttribute with any type of body
func NewCreateAttributeRequestWithBody(server string, params *CreateAttributeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewDeleteAttributeRequest generates requests for DeleteAttribute
func NewDeleteAttributeRequest(server string, attributeId string, params *DeleteAttributeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attribute-id", runtime.ParamLocationPath, attributeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewGetAttributeRequest generates requests for GetAttribute
func NewGetAttributeRequest(server string, attributeId string, params *GetAttributeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attribute-id", runtime.ParamLocationPath, attributeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewUpdateAttributeRequest calls the generic UpdateAttribute builder with application/json body
func NewUpdateAttributeRequest(server string, attributeId string, params *UpdateAttributeParams, body UpdateAttributeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAttributeRequestWithBody(server, attributeId, params, "application/json", bodyReader)
}

// NewUpdateAttributeRequestWithBody generates requests for UpdateAttribute with any type of body
func NewUpdateAttributeRequestWithBody(server string, attributeId string, params *UpdateAttributeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attribute-id", runtime.ParamLocationPath, attributeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attributes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewListAutomationRulesetsRequest generates requests for ListAutomationRulesets
func NewListAutomationRulesetsRequest(server string, params *ListAutomationRulesetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Merchant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merchant", runtime.ParamLocationQuery, *params.Merchant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entity-type", runtime.ParamLocationQuery, *params.EntityType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewCreateAutomationRulesetAndRulesRequest calls the generic CreateAutomationRulesetAndRules builder with application/json body
func NewCreateAutomationRulesetAndRulesRequest(server string, params *CreateAutomationRulesetAndRulesParams, body CreateAutomationRulesetAndRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAutomationRulesetAndRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAutomationRulesetAndRulesRequestWithBody generates requests for CreateAutomationRulesetAndRules with any type of body
func NewCreateAutomationRulesetAndRulesRequestWithBody(server string, params *CreateAutomationRulesetAndRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewDeleteAutomationRulesetRequest generates requests for DeleteAutomationRuleset
func NewDeleteAutomationRulesetRequest(server string, automationRulesetId string, params *DeleteAutomationRulesetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "automation-ruleset-id", runtime.ParamLocationPath, automationRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewGetAutomationRulesetRequest generates requests for GetAutomationRuleset
func NewGetAutomationRulesetRequest(server string, automationRulesetId string, params *GetAutomationRulesetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "automation-ruleset-id", runtime.ParamLocationPath, automationRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewPatchAutomationRulesetRequest calls the generic PatchAutomationRuleset builder with application/json body
func NewPatchAutomationRulesetRequest(server string, automationRulesetId string, params *PatchAutomationRulesetParams, body PatchAutomationRulesetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAutomationRulesetRequestWithBody(server, automationRulesetId, params, "application/json", bodyReader)
}

// NewPatchAutomationRulesetRequestWithBody generates requests for PatchAutomationRuleset with any type of body
func NewPatchAutomationRulesetRequestWithBody(server string, automationRulesetId string, params *PatchAutomationRulesetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "automation-ruleset-id", runtime.ParamLocationPath, automationRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewUpdateAutomationRulesetAndRulesRequest calls the generic UpdateAutomationRulesetAndRules builder with application/json body
func NewUpdateAutomationRulesetAndRulesRequest(server string, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, body UpdateAutomationRulesetAndRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAutomationRulesetAndRulesRequestWithBody(server, automationRulesetId, params, "application/json", bodyReader)
}

// NewUpdateAutomationRulesetAndRulesRequestWithBody generates requests for UpdateAutomationRulesetAndRules with any type of body
func NewUpdateAutomationRulesetAndRulesRequestWithBody(server string, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "automation-ruleset-id", runtime.ParamLocationPath, automationRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewListAutomationRulesRequest generates requests for ListAutomationRules
func NewListAutomationRulesRequest(server string, automationRulesetId string, params *ListAutomationRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "automation-ruleset-id", runtime.ParamLocationPath, automationRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewCreateAutomationRulesRequest calls the generic CreateAutomationRules builder with application/json body
func NewCreateAutomationRulesRequest(server string, automationRulesetId string, params *CreateAutomationRulesParams, body CreateAutomationRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAutomationRulesRequestWithBody(server, automationRulesetId, params, "application/json", bodyReader)
}

// NewCreateAutomationRulesRequestWithBody generates requests for CreateAutomationRules with any type of body
func NewCreateAutomationRulesRequestWithBody(server string, automationRulesetId string, params *CreateAutomationRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "automation-ruleset-id", runtime.ParamLocationPath, automationRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewUpdateAutomationRulesSequenceRequest calls the generic UpdateAutomationRulesSequence builder with application/json body
func NewUpdateAutomationRulesSequenceRequest(server string, rulesetId string, params *UpdateAutomationRulesSequenceParams, body UpdateAutomationRulesSequenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAutomationRulesSequenceRequestWithBody(server, rulesetId, params, "application/json", bodyReader)
}

// NewUpdateAutomationRulesSequenceRequestWithBody generates requests for UpdateAutomationRulesSequence with any type of body
func NewUpdateAutomationRulesSequenceRequestWithBody(server string, rulesetId string, params *UpdateAutomationRulesSequenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset-id", runtime.ParamLocationPath, rulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s/rules/sequences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewDeleteAutomationRuleRequest generates requests for DeleteAutomationRule
func NewDeleteAutomationRuleRequest(server string, rulesetId string, automationRuleId string, params *DeleteAutomationRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset-id", runtime.ParamLocationPath, rulesetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "automation-rule-id", runtime.ParamLocationPath, automationRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewGetAutomationRuleRequest generates requests for GetAutomationRule
func NewGetAutomationRuleRequest(server string, rulesetId string, automationRuleId string, params *GetAutomationRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset-id", runtime.ParamLocationPath, rulesetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "automation-rule-id", runtime.ParamLocationPath, automationRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewUpdateAutomationRuleRequest calls the generic UpdateAutomationRule builder with application/json body
func NewUpdateAutomationRuleRequest(server string, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, body UpdateAutomationRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAutomationRuleRequestWithBody(server, rulesetId, automationRuleId, params, "application/json", bodyReader)
}

// NewUpdateAutomationRuleRequestWithBody generates requests for UpdateAutomationRule with any type of body
func NewUpdateAutomationRuleRequestWithBody(server string, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset-id", runtime.ParamLocationPath, rulesetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "automation-rule-id", runtime.ParamLocationPath, automationRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-rulesets/%s/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewListCarrierAccountsRequest generates requests for ListCarrierAccounts
func NewListCarrierAccountsRequest(server string, params *ListCarrierAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/carrier-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewCreateCarrierAccountRequest calls the generic CreateCarrierAccount builder with application/json body
func NewCreateCarrierAccountRequest(server string, params *CreateCarrierAccountParams, body CreateCarrierAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCarrierAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCarrierAccountRequestWithBody generates requests for CreateCarrierAccount with any type of body
func NewCreateCarrierAccountRequestWithBody(server string, params *CreateCarrierAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/carrier-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewDeleteCarrierAccountRequest generates requests for DeleteCarrierAccount
func NewDeleteCarrierAccountRequest(server string, carrierAccountId string, params *DeleteCarrierAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "carrier-account-id", runtime.ParamLocationPath, carrierAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/carrier-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewGetCarrierAccountRequest generates requests for GetCarrierAccount
func NewGetCarrierAccountRequest(server string, carrierAccountId string, params *GetCarrierAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "carrier-account-id", runtime.ParamLocationPath, carrierAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/carrier-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewUpdateCarrierAccountRequest calls the generic UpdateCarrierAccount builder with application/json body
func NewUpdateCarrierAccountRequest(server string, carrierAccountId string, params *UpdateCarrierAccountParams, body UpdateCarrierAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCarrierAccountRequestWithBody(server, carrierAccountId, params, "application/json", bodyReader)
}

// NewUpdateCarrierAccountRequestWithBody generates requests for UpdateCarrierAccount with any type of body
func NewUpdateCarrierAccountRequestWithBody(server string, carrierAccountId string, params *UpdateCarrierAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "carrier-account-id", runtime.ParamLocationPath, carrierAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/carrier-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewGetShippingRatesRequest calls the generic GetShippingRates builder with application/json body
func NewGetShippingRatesRequest(server string, params *GetShippingRatesParams, body GetShippingRatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetShippingRatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetShippingRatesRequestWithBody generates requests for GetShippingRates with any type of body
func NewGetShippingRatesRequestWithBody(server string, params *GetShippingRatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checkout/shipping-rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

	}

	return req, nil
}

// NewListManifestsRequest generates requests for ListManifests
func NewListManifestsRequest(server string, params *ListManifestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manifests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewCreateManifestRequest calls the generic CreateManifest builder with application/json body
func NewCreateManifestRequest(server string, params *CreateManifestParams, body CreateManifestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManifestRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManifestRequestWithBody generates requests for CreateManifest with any type of body
func NewCreateManifestRequestWithBody(server string, params *CreateManifestParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manifests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewDeleteManifestRequest generates requests for DeleteManifest
func NewDeleteManifestRequest(server string, manifestId string, params *DeleteManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "manifest-id", runtime.ParamLocationPath, manifestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manifests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewGetManifestRequest generates requests for GetManifest
func NewGetManifestRequest(server string, manifestId string, params *GetManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "manifest-id", runtime.ParamLocationPath, manifestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manifests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewCancelManifestRequest generates requests for CancelManifest
func NewCancelManifestRequest(server string, manifestId string, params *CancelManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "manifest-id", runtime.ParamLocationPath, manifestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manifests/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewRetryManifestRequest generates requests for RetryManifest
func NewRetryManifestRequest(server string, manifestId string, params *RetryManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "manifest-id", runtime.ParamLocationPath, manifestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manifests/%s/retry", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewShipManifestRequest generates requests for ShipManifest
func NewShipManifestRequest(server string, manifestId string, params *ShipManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "manifest-id", runtime.ParamLocationPath, manifestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manifests/%s/ship", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewListServiceLevelRulesetsRequest generates requests for ListServiceLevelRulesets
func NewListServiceLevelRulesetsRequest(server string, params *ListServiceLevelRulesetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Merchant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merchant", runtime.ParamLocationQuery, *params.Merchant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entity-type", runtime.ParamLocationQuery, *params.EntityType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewCreateServiceLevelRulesetAndRulesRequest calls the generic CreateServiceLevelRulesetAndRules builder with application/json body
func NewCreateServiceLevelRulesetAndRulesRequest(server string, params *CreateServiceLevelRulesetAndRulesParams, body CreateServiceLevelRulesetAndRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceLevelRulesetAndRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateServiceLevelRulesetAndRulesRequestWithBody generates requests for CreateServiceLevelRulesetAndRules with any type of body
func NewCreateServiceLevelRulesetAndRulesRequestWithBody(server string, params *CreateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewUpdateServiceLevelRulesSequenceRequest calls the generic UpdateServiceLevelRulesSequence builder with application/json body
func NewUpdateServiceLevelRulesSequenceRequest(server string, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, body UpdateServiceLevelRulesSequenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceLevelRulesSequenceRequestWithBody(server, rulesetId, params, "application/json", bodyReader)
}

// NewUpdateServiceLevelRulesSequenceRequestWithBody generates requests for UpdateServiceLevelRulesSequence with any type of body
func NewUpdateServiceLevelRulesSequenceRequestWithBody(server string, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset-id", runtime.ParamLocationPath, rulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s/rules/sequences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewDeleteServiceLevelRuleRequest generates requests for DeleteServiceLevelRule
func NewDeleteServiceLevelRuleRequest(server string, rulesetId string, serviceLevelRuleId string, params *DeleteServiceLevelRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset-id", runtime.ParamLocationPath, rulesetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "service-level-rule-id", runtime.ParamLocationPath, serviceLevelRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewGetServiceLevelRuleRequest generates requests for GetServiceLevelRule
func NewGetServiceLevelRuleRequest(server string, rulesetId string, serviceLevelRuleId string, params *GetServiceLevelRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset-id", runtime.ParamLocationPath, rulesetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "service-level-rule-id", runtime.ParamLocationPath, serviceLevelRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewUpdateServiceLevelRuleRequest calls the generic UpdateServiceLevelRule builder with application/json body
func NewUpdateServiceLevelRuleRequest(server string, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, body UpdateServiceLevelRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceLevelRuleRequestWithBody(server, rulesetId, serviceLevelRuleId, params, "application/json", bodyReader)
}

// NewUpdateServiceLevelRuleRequestWithBody generates requests for UpdateServiceLevelRule with any type of body
func NewUpdateServiceLevelRuleRequestWithBody(server string, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset-id", runtime.ParamLocationPath, rulesetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "service-level-rule-id", runtime.ParamLocationPath, serviceLevelRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewDeleteServiceLevelRulesetRequest generates requests for DeleteServiceLevelRuleset
func NewDeleteServiceLevelRulesetRequest(server string, serviceLevelRulesetId string, params *DeleteServiceLevelRulesetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service-level-ruleset-id", runtime.ParamLocationPath, serviceLevelRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewGetServiceLevelRulesetRequest generates requests for GetServiceLevelRuleset
func NewGetServiceLevelRulesetRequest(server string, serviceLevelRulesetId string, params *GetServiceLevelRulesetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service-level-ruleset-id", runtime.ParamLocationPath, serviceLevelRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewPatchServiceLevelRulesetRequest calls the generic PatchServiceLevelRuleset builder with application/json body
func NewPatchServiceLevelRulesetRequest(server string, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, body PatchServiceLevelRulesetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchServiceLevelRulesetRequestWithBody(server, serviceLevelRulesetId, params, "application/json", bodyReader)
}

// NewPatchServiceLevelRulesetRequestWithBody generates requests for PatchServiceLevelRuleset with any type of body
func NewPatchServiceLevelRulesetRequestWithBody(server string, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service-level-ruleset-id", runtime.ParamLocationPath, serviceLevelRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewUpdateServiceLevelRulesetAndRulesRequest calls the generic UpdateServiceLevelRulesetAndRules builder with application/json body
func NewUpdateServiceLevelRulesetAndRulesRequest(server string, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, body UpdateServiceLevelRulesetAndRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceLevelRulesetAndRulesRequestWithBody(server, serviceLevelRulesetId, params, "application/json", bodyReader)
}

// NewUpdateServiceLevelRulesetAndRulesRequestWithBody generates requests for UpdateServiceLevelRulesetAndRules with any type of body
func NewUpdateServiceLevelRulesetAndRulesRequestWithBody(server string, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service-level-ruleset-id", runtime.ParamLocationPath, serviceLevelRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewListServiceLevelRulesRequest generates requests for ListServiceLevelRules
func NewListServiceLevelRulesRequest(server string, serviceLevelRulesetId string, params *ListServiceLevelRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service-level-ruleset-id", runtime.ParamLocationPath, serviceLevelRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewCreateServiceLevelRulesRequest calls the generic CreateServiceLevelRules builder with application/json body
func NewCreateServiceLevelRulesRequest(server string, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, body CreateServiceLevelRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceLevelRulesRequestWithBody(server, serviceLevelRulesetId, params, "application/json", bodyReader)
}

// NewCreateServiceLevelRulesRequestWithBody generates requests for CreateServiceLevelRules with any type of body
func NewCreateServiceLevelRulesRequestWithBody(server string, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service-level-ruleset-id", runtime.ParamLocationPath, serviceLevelRulesetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-level-rulesets/%s/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewListShipmentsRequest generates requests for ListShipments
func NewListShipmentsRequest(server string, params *ListShipmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SearchString != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_string", runtime.ParamLocationQuery, *params.SearchString); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderRef != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_ref", runtime.ParamLocationQuery, *params.OrderRef); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Merchant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merchant", runtime.ParamLocationQuery, *params.Merchant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShipmentType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipment_type", runtime.ParamLocationQuery, *params.ShipmentType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreationDateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creation_date_from", runtime.ParamLocationQuery, *params.CreationDateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreationDateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creation_date_to", runtime.ParamLocationQuery, *params.CreationDateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdateDateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "update_date_from", runtime.ParamLocationQuery, *params.UpdateDateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdateDateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "update_date_to", runtime.ParamLocationQuery, *params.UpdateDateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

	}

	return req, nil
}

// NewCreateShipmentRequest calls the generic CreateShipment builder with application/json body
func NewCreateShipmentRequest(server string, params *CreateShipmentParams, body CreateShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateShipmentRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateShipmentRequestWithBody generates requests for CreateShipment with any type of body
func NewCreateShipmentRequestWithBody(server string, params *CreateShipmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Draft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "draft", runtime.ParamLocationQuery, *params.Draft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewGetBulkStatusRequest generates requests for GetBulkStatus
func NewGetBulkStatusRequest(server string, params *GetBulkStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/bulk/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShipmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "shipment_id", runtime.ParamLocationQuery, *params.ShipmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

	}

	return req, nil
}

// NewGetShipmentRequest generates requests for GetShipment
func NewGetShipmentRequest(server string, shipmentId string, params *GetShipmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

	}

	return req, nil
}

// NewUpdateShipmentPatchRequest calls the generic UpdateShipmentPatch builder with application/json body
func NewUpdateShipmentPatchRequest(server string, shipmentId string, params *UpdateShipmentPatchParams, body UpdateShipmentPatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShipmentPatchRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewUpdateShipmentPatchRequestWithBody generates requests for UpdateShipmentPatch with any type of body
func NewUpdateShipmentPatchRequestWithBody(server string, shipmentId string, params *UpdateShipmentPatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewUpdateShipmentRequest calls the generic UpdateShipment builder with application/json body
func NewUpdateShipmentRequest(server string, shipmentId string, params *UpdateShipmentParams, body UpdateShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShipmentRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewUpdateShipmentRequestWithBody generates requests for UpdateShipment with any type of body
func NewUpdateShipmentRequestWithBody(server string, shipmentId string, params *UpdateShipmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewCancelShipmentRequest calls the generic CancelShipment builder with application/json body
func NewCancelShipmentRequest(server string, shipmentId string, params *CancelShipmentParams, body CancelShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelShipmentRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewCancelShipmentRequestWithBody generates requests for CancelShipment with any type of body
func NewCancelShipmentRequestWithBody(server string, shipmentId string, params *CancelShipmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

// NewConfirmShipmentRequest calls the generic ConfirmShipment builder with application/json body
func NewConfirmShipmentRequest(server string, shipmentId string, params *ConfirmShipmentParams, body ConfirmShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmShipmentRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewConfirmShipmentRequestWithBody generates requests for ConfirmShipment with any type of body
func NewConfirmShipmentRequestWithBody(server string, shipmentId string, params *ConfirmShipmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewEstimateShippingCostForShipmentRequest generates requests for EstimateShippingCostForShipment
func NewEstimateShippingCostForShipmentRequest(server string, shipmentId string, params *EstimateShippingCostForShipmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/estimate-shipping-cost", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

	}

	return req, nil
}

// NewRefreshLabelRequest generates requests for RefreshLabel
func NewRefreshLabelRequest(server string, shipmentId string, params *RefreshLabelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/label/refresh", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

	}

	return req, nil
}

// NewUpdateParcelsRequest calls the generic UpdateParcels builder with application/json body
func NewUpdateParcelsRequest(server string, shipmentId string, params *UpdateParcelsParams, body UpdateParcelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateParcelsRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewUpdateParcelsRequestWithBody generates requests for UpdateParcels with any type of body
func NewUpdateParcelsRequestWithBody(server string, shipmentId string, params *UpdateParcelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/parcels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewReadyToShipRequest calls the generic ReadyToShip builder with application/json body
func NewReadyToShipRequest(server string, shipmentId string, params *ReadyToShipParams, body ReadyToShipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadyToShipRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewReadyToShipRequestWithBody generates requests for ReadyToShip with any type of body
func NewReadyToShipRequestWithBody(server string, shipmentId string, params *ReadyToShipParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/ready-to-ship", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

	}

	return req, nil
}

// NewReassignShipmentRequest calls the generic ReassignShipment builder with application/json body
func NewReassignShipmentRequest(server string, shipmentId string, params *ReassignShipmentParams, body ReassignShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReassignShipmentRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewReassignShipmentRequestWithBody generates requests for ReassignShipment with any type of body
func NewReassignShipmentRequestWithBody(server string, shipmentId string, params *ReassignShipmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/reassign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewReprocessShipmentRequest calls the generic ReprocessShipment builder with application/json body
func NewReprocessShipmentRequest(server string, shipmentId string, params *ReprocessShipmentParams, body ReprocessShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReprocessShipmentRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewReprocessShipmentRequestWithBody generates requests for ReprocessShipment with any type of body
func NewReprocessShipmentRequestWithBody(server string, shipmentId string, params *ReprocessShipmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/reprocess", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewUpdateCollectionScheduleRequest calls the generic UpdateCollectionSchedule builder with application/json body
func NewUpdateCollectionScheduleRequest(server string, shipmentId string, params *UpdateCollectionScheduleParams, body UpdateCollectionScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCollectionScheduleRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewUpdateCollectionScheduleRequestWithBody generates requests for UpdateCollectionSchedule with any type of body
func NewUpdateCollectionScheduleRequestWithBody(server string, shipmentId string, params *UpdateCollectionScheduleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/update-collection-schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewUpdateDeliveryPromiseRequest calls the generic UpdateDeliveryPromise builder with application/json body
func NewUpdateDeliveryPromiseRequest(server string, shipmentId string, params *UpdateDeliveryPromiseParams, body UpdateDeliveryPromiseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDeliveryPromiseRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewUpdateDeliveryPromiseRequestWithBody generates requests for UpdateDeliveryPromise with any type of body
func NewUpdateDeliveryPromiseRequestWithBody(server string, shipmentId string, params *UpdateDeliveryPromiseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/update-delivery-promise", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewUpdateDeliveryScheduleRequest calls the generic UpdateDeliverySchedule builder with application/json body
func NewUpdateDeliveryScheduleRequest(server string, shipmentId string, params *UpdateDeliveryScheduleParams, body UpdateDeliveryScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDeliveryScheduleRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewUpdateDeliveryScheduleRequestWithBody generates requests for UpdateDeliverySchedule with any type of body
func NewUpdateDeliveryScheduleRequestWithBody(server string, shipmentId string, params *UpdateDeliveryScheduleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/update-delivery-schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, params.XApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-key", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, params.TenantId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("tenant-id", headerParam1)

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam2)

	}

	return req, nil
}

// NewUpdateStatusRequest calls the generic UpdateStatus builder with application/json body
func NewUpdateStatusRequest(server string, shipmentId string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStatusRequestWithBody(server, shipmentId, params, "application/json", bodyReader)
}

// NewUpdateStatusRequestWithBody generates requests for UpdateStatus with any type of body
func NewUpdateStatusRequestWithBody(server string, shipmentId string, params *UpdateStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipment_id", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shipments/%s/update-status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-api-key", headerParam0)
		}

		if params.TenantId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-id", runtime.ParamLocationHeader, *params.TenantId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("tenant-id", headerParam1)
		}

		if params.ContentType != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam2)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAttrbutesWithResponse request
	ListAttrbutesWithResponse(ctx context.Context, params *ListAttrbutesParams, reqEditors ...RequestEditorFn) (*ListAttrbutesResponse, error)

	// CreateAttributeWithBodyWithResponse request with any body
	CreateAttributeWithBodyWithResponse(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributeResponse, error)

	CreateAttributeWithResponse(ctx context.Context, params *CreateAttributeParams, body CreateAttributeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAttributeResponse, error)

	// DeleteAttributeWithResponse request
	DeleteAttributeWithResponse(ctx context.Context, attributeId string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*DeleteAttributeResponse, error)

	// GetAttributeWithResponse request
	GetAttributeWithResponse(ctx context.Context, attributeId string, params *GetAttributeParams, reqEditors ...RequestEditorFn) (*GetAttributeResponse, error)

	// UpdateAttributeWithBodyWithResponse request with any body
	UpdateAttributeWithBodyWithResponse(ctx context.Context, attributeId string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributeResponse, error)

	UpdateAttributeWithResponse(ctx context.Context, attributeId string, params *UpdateAttributeParams, body UpdateAttributeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttributeResponse, error)

	// ListAutomationRulesetsWithResponse request
	ListAutomationRulesetsWithResponse(ctx context.Context, params *ListAutomationRulesetsParams, reqEditors ...RequestEditorFn) (*ListAutomationRulesetsResponse, error)

	// CreateAutomationRulesetAndRulesWithBodyWithResponse request with any body
	CreateAutomationRulesetAndRulesWithBodyWithResponse(ctx context.Context, params *CreateAutomationRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAutomationRulesetAndRulesResponse, error)

	CreateAutomationRulesetAndRulesWithResponse(ctx context.Context, params *CreateAutomationRulesetAndRulesParams, body CreateAutomationRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAutomationRulesetAndRulesResponse, error)

	// DeleteAutomationRulesetWithResponse request
	DeleteAutomationRulesetWithResponse(ctx context.Context, automationRulesetId string, params *DeleteAutomationRulesetParams, reqEditors ...RequestEditorFn) (*DeleteAutomationRulesetResponse, error)

	// GetAutomationRulesetWithResponse request
	GetAutomationRulesetWithResponse(ctx context.Context, automationRulesetId string, params *GetAutomationRulesetParams, reqEditors ...RequestEditorFn) (*GetAutomationRulesetResponse, error)

	// PatchAutomationRulesetWithBodyWithResponse request with any body
	PatchAutomationRulesetWithBodyWithResponse(ctx context.Context, automationRulesetId string, params *PatchAutomationRulesetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAutomationRulesetResponse, error)

	PatchAutomationRulesetWithResponse(ctx context.Context, automationRulesetId string, params *PatchAutomationRulesetParams, body PatchAutomationRulesetJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAutomationRulesetResponse, error)

	// UpdateAutomationRulesetAndRulesWithBodyWithResponse request with any body
	UpdateAutomationRulesetAndRulesWithBodyWithResponse(ctx context.Context, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationRulesetAndRulesResponse, error)

	UpdateAutomationRulesetAndRulesWithResponse(ctx context.Context, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, body UpdateAutomationRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationRulesetAndRulesResponse, error)

	// ListAutomationRulesWithResponse request
	ListAutomationRulesWithResponse(ctx context.Context, automationRulesetId string, params *ListAutomationRulesParams, reqEditors ...RequestEditorFn) (*ListAutomationRulesResponse, error)

	// CreateAutomationRulesWithBodyWithResponse request with any body
	CreateAutomationRulesWithBodyWithResponse(ctx context.Context, automationRulesetId string, params *CreateAutomationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAutomationRulesResponse, error)

	CreateAutomationRulesWithResponse(ctx context.Context, automationRulesetId string, params *CreateAutomationRulesParams, body CreateAutomationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAutomationRulesResponse, error)

	// UpdateAutomationRulesSequenceWithBodyWithResponse request with any body
	UpdateAutomationRulesSequenceWithBodyWithResponse(ctx context.Context, rulesetId string, params *UpdateAutomationRulesSequenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationRulesSequenceResponse, error)

	UpdateAutomationRulesSequenceWithResponse(ctx context.Context, rulesetId string, params *UpdateAutomationRulesSequenceParams, body UpdateAutomationRulesSequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationRulesSequenceResponse, error)

	// DeleteAutomationRuleWithResponse request
	DeleteAutomationRuleWithResponse(ctx context.Context, rulesetId string, automationRuleId string, params *DeleteAutomationRuleParams, reqEditors ...RequestEditorFn) (*DeleteAutomationRuleResponse, error)

	// GetAutomationRuleWithResponse request
	GetAutomationRuleWithResponse(ctx context.Context, rulesetId string, automationRuleId string, params *GetAutomationRuleParams, reqEditors ...RequestEditorFn) (*GetAutomationRuleResponse, error)

	// UpdateAutomationRuleWithBodyWithResponse request with any body
	UpdateAutomationRuleWithBodyWithResponse(ctx context.Context, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationRuleResponse, error)

	UpdateAutomationRuleWithResponse(ctx context.Context, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, body UpdateAutomationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationRuleResponse, error)

	// ListCarrierAccountsWithResponse request
	ListCarrierAccountsWithResponse(ctx context.Context, params *ListCarrierAccountsParams, reqEditors ...RequestEditorFn) (*ListCarrierAccountsResponse, error)

	// CreateCarrierAccountWithBodyWithResponse request with any body
	CreateCarrierAccountWithBodyWithResponse(ctx context.Context, params *CreateCarrierAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCarrierAccountResponse, error)

	CreateCarrierAccountWithResponse(ctx context.Context, params *CreateCarrierAccountParams, body CreateCarrierAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCarrierAccountResponse, error)

	// DeleteCarrierAccountWithResponse request
	DeleteCarrierAccountWithResponse(ctx context.Context, carrierAccountId string, params *DeleteCarrierAccountParams, reqEditors ...RequestEditorFn) (*DeleteCarrierAccountResponse, error)

	// GetCarrierAccountWithResponse request
	GetCarrierAccountWithResponse(ctx context.Context, carrierAccountId string, params *GetCarrierAccountParams, reqEditors ...RequestEditorFn) (*GetCarrierAccountResponse, error)

	// UpdateCarrierAccountWithBodyWithResponse request with any body
	UpdateCarrierAccountWithBodyWithResponse(ctx context.Context, carrierAccountId string, params *UpdateCarrierAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCarrierAccountResponse, error)

	UpdateCarrierAccountWithResponse(ctx context.Context, carrierAccountId string, params *UpdateCarrierAccountParams, body UpdateCarrierAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCarrierAccountResponse, error)

	// GetShippingRatesWithBodyWithResponse request with any body
	GetShippingRatesWithBodyWithResponse(ctx context.Context, params *GetShippingRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetShippingRatesResponse, error)

	GetShippingRatesWithResponse(ctx context.Context, params *GetShippingRatesParams, body GetShippingRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetShippingRatesResponse, error)

	// ListManifestsWithResponse request
	ListManifestsWithResponse(ctx context.Context, params *ListManifestsParams, reqEditors ...RequestEditorFn) (*ListManifestsResponse, error)

	// CreateManifestWithBodyWithResponse request with any body
	CreateManifestWithBodyWithResponse(ctx context.Context, params *CreateManifestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManifestResponse, error)

	CreateManifestWithResponse(ctx context.Context, params *CreateManifestParams, body CreateManifestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManifestResponse, error)

	// DeleteManifestWithResponse request
	DeleteManifestWithResponse(ctx context.Context, manifestId string, params *DeleteManifestParams, reqEditors ...RequestEditorFn) (*DeleteManifestResponse, error)

	// GetManifestWithResponse request
	GetManifestWithResponse(ctx context.Context, manifestId string, params *GetManifestParams, reqEditors ...RequestEditorFn) (*GetManifestResponse, error)

	// CancelManifestWithResponse request
	CancelManifestWithResponse(ctx context.Context, manifestId string, params *CancelManifestParams, reqEditors ...RequestEditorFn) (*CancelManifestResponse, error)

	// RetryManifestWithResponse request
	RetryManifestWithResponse(ctx context.Context, manifestId string, params *RetryManifestParams, reqEditors ...RequestEditorFn) (*RetryManifestResponse, error)

	// ShipManifestWithResponse request
	ShipManifestWithResponse(ctx context.Context, manifestId string, params *ShipManifestParams, reqEditors ...RequestEditorFn) (*ShipManifestResponse, error)

	// ListServiceLevelRulesetsWithResponse request
	ListServiceLevelRulesetsWithResponse(ctx context.Context, params *ListServiceLevelRulesetsParams, reqEditors ...RequestEditorFn) (*ListServiceLevelRulesetsResponse, error)

	// CreateServiceLevelRulesetAndRulesWithBodyWithResponse request with any body
	CreateServiceLevelRulesetAndRulesWithBodyWithResponse(ctx context.Context, params *CreateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceLevelRulesetAndRulesResponse, error)

	CreateServiceLevelRulesetAndRulesWithResponse(ctx context.Context, params *CreateServiceLevelRulesetAndRulesParams, body CreateServiceLevelRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceLevelRulesetAndRulesResponse, error)

	// UpdateServiceLevelRulesSequenceWithBodyWithResponse request with any body
	UpdateServiceLevelRulesSequenceWithBodyWithResponse(ctx context.Context, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRulesSequenceResponse, error)

	UpdateServiceLevelRulesSequenceWithResponse(ctx context.Context, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, body UpdateServiceLevelRulesSequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRulesSequenceResponse, error)

	// DeleteServiceLevelRuleWithResponse request
	DeleteServiceLevelRuleWithResponse(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *DeleteServiceLevelRuleParams, reqEditors ...RequestEditorFn) (*DeleteServiceLevelRuleResponse, error)

	// GetServiceLevelRuleWithResponse request
	GetServiceLevelRuleWithResponse(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *GetServiceLevelRuleParams, reqEditors ...RequestEditorFn) (*GetServiceLevelRuleResponse, error)

	// UpdateServiceLevelRuleWithBodyWithResponse request with any body
	UpdateServiceLevelRuleWithBodyWithResponse(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRuleResponse, error)

	UpdateServiceLevelRuleWithResponse(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, body UpdateServiceLevelRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRuleResponse, error)

	// DeleteServiceLevelRulesetWithResponse request
	DeleteServiceLevelRulesetWithResponse(ctx context.Context, serviceLevelRulesetId string, params *DeleteServiceLevelRulesetParams, reqEditors ...RequestEditorFn) (*DeleteServiceLevelRulesetResponse, error)

	// GetServiceLevelRulesetWithResponse request
	GetServiceLevelRulesetWithResponse(ctx context.Context, serviceLevelRulesetId string, params *GetServiceLevelRulesetParams, reqEditors ...RequestEditorFn) (*GetServiceLevelRulesetResponse, error)

	// PatchServiceLevelRulesetWithBodyWithResponse request with any body
	PatchServiceLevelRulesetWithBodyWithResponse(ctx context.Context, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchServiceLevelRulesetResponse, error)

	PatchServiceLevelRulesetWithResponse(ctx context.Context, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, body PatchServiceLevelRulesetJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchServiceLevelRulesetResponse, error)

	// UpdateServiceLevelRulesetAndRulesWithBodyWithResponse request with any body
	UpdateServiceLevelRulesetAndRulesWithBodyWithResponse(ctx context.Context, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRulesetAndRulesResponse, error)

	UpdateServiceLevelRulesetAndRulesWithResponse(ctx context.Context, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, body UpdateServiceLevelRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRulesetAndRulesResponse, error)

	// ListServiceLevelRulesWithResponse request
	ListServiceLevelRulesWithResponse(ctx context.Context, serviceLevelRulesetId string, params *ListServiceLevelRulesParams, reqEditors ...RequestEditorFn) (*ListServiceLevelRulesResponse, error)

	// CreateServiceLevelRulesWithBodyWithResponse request with any body
	CreateServiceLevelRulesWithBodyWithResponse(ctx context.Context, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceLevelRulesResponse, error)

	CreateServiceLevelRulesWithResponse(ctx context.Context, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, body CreateServiceLevelRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceLevelRulesResponse, error)

	// ListShipmentsWithResponse request
	ListShipmentsWithResponse(ctx context.Context, params *ListShipmentsParams, reqEditors ...RequestEditorFn) (*ListShipmentsResponse, error)

	// CreateShipmentWithBodyWithResponse request with any body
	CreateShipmentWithBodyWithResponse(ctx context.Context, params *CreateShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateShipmentResponse, error)

	CreateShipmentWithResponse(ctx context.Context, params *CreateShipmentParams, body CreateShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateShipmentResponse, error)

	// GetBulkStatusWithResponse request
	GetBulkStatusWithResponse(ctx context.Context, params *GetBulkStatusParams, reqEditors ...RequestEditorFn) (*GetBulkStatusResponse, error)

	// GetShipmentWithResponse request
	GetShipmentWithResponse(ctx context.Context, shipmentId string, params *GetShipmentParams, reqEditors ...RequestEditorFn) (*GetShipmentResponse, error)

	// UpdateShipmentPatchWithBodyWithResponse request with any body
	UpdateShipmentPatchWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateShipmentPatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShipmentPatchResponse, error)

	UpdateShipmentPatchWithResponse(ctx context.Context, shipmentId string, params *UpdateShipmentPatchParams, body UpdateShipmentPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShipmentPatchResponse, error)

	// UpdateShipmentWithBodyWithResponse request with any body
	UpdateShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShipmentResponse, error)

	UpdateShipmentWithResponse(ctx context.Context, shipmentId string, params *UpdateShipmentParams, body UpdateShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShipmentResponse, error)

	// CancelShipmentWithBodyWithResponse request with any body
	CancelShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *CancelShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelShipmentResponse, error)

	CancelShipmentWithResponse(ctx context.Context, shipmentId string, params *CancelShipmentParams, body CancelShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelShipmentResponse, error)

	// ConfirmShipmentWithBodyWithResponse request with any body
	ConfirmShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *ConfirmShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmShipmentResponse, error)

	ConfirmShipmentWithResponse(ctx context.Context, shipmentId string, params *ConfirmShipmentParams, body ConfirmShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmShipmentResponse, error)

	// EstimateShippingCostForShipmentWithResponse request
	EstimateShippingCostForShipmentWithResponse(ctx context.Context, shipmentId string, params *EstimateShippingCostForShipmentParams, reqEditors ...RequestEditorFn) (*EstimateShippingCostForShipmentResponse, error)

	// RefreshLabelWithResponse request
	RefreshLabelWithResponse(ctx context.Context, shipmentId string, params *RefreshLabelParams, reqEditors ...RequestEditorFn) (*RefreshLabelResponse, error)

	// UpdateParcelsWithBodyWithResponse request with any body
	UpdateParcelsWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateParcelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateParcelsResponse, error)

	UpdateParcelsWithResponse(ctx context.Context, shipmentId string, params *UpdateParcelsParams, body UpdateParcelsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateParcelsResponse, error)

	// ReadyToShipWithBodyWithResponse request with any body
	ReadyToShipWithBodyWithResponse(ctx context.Context, shipmentId string, params *ReadyToShipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadyToShipResponse, error)

	ReadyToShipWithResponse(ctx context.Context, shipmentId string, params *ReadyToShipParams, body ReadyToShipJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadyToShipResponse, error)

	// ReassignShipmentWithBodyWithResponse request with any body
	ReassignShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *ReassignShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReassignShipmentResponse, error)

	ReassignShipmentWithResponse(ctx context.Context, shipmentId string, params *ReassignShipmentParams, body ReassignShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReassignShipmentResponse, error)

	// ReprocessShipmentWithBodyWithResponse request with any body
	ReprocessShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *ReprocessShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReprocessShipmentResponse, error)

	ReprocessShipmentWithResponse(ctx context.Context, shipmentId string, params *ReprocessShipmentParams, body ReprocessShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReprocessShipmentResponse, error)

	// UpdateCollectionScheduleWithBodyWithResponse request with any body
	UpdateCollectionScheduleWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateCollectionScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionScheduleResponse, error)

	UpdateCollectionScheduleWithResponse(ctx context.Context, shipmentId string, params *UpdateCollectionScheduleParams, body UpdateCollectionScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionScheduleResponse, error)

	// UpdateDeliveryPromiseWithBodyWithResponse request with any body
	UpdateDeliveryPromiseWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateDeliveryPromiseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeliveryPromiseResponse, error)

	UpdateDeliveryPromiseWithResponse(ctx context.Context, shipmentId string, params *UpdateDeliveryPromiseParams, body UpdateDeliveryPromiseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeliveryPromiseResponse, error)

	// UpdateDeliveryScheduleWithBodyWithResponse request with any body
	UpdateDeliveryScheduleWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateDeliveryScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeliveryScheduleResponse, error)

	UpdateDeliveryScheduleWithResponse(ctx context.Context, shipmentId string, params *UpdateDeliveryScheduleParams, body UpdateDeliveryScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeliveryScheduleResponse, error)

	// UpdateStatusWithBodyWithResponse request with any body
	UpdateStatusWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStatusResponse, error)

	UpdateStatusWithResponse(ctx context.Context, shipmentId string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStatusResponse, error)
}

type ListAttrbutesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttributeResponse
}

// Status returns HTTPResponse.Status
func (r ListAttrbutesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttrbutesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAttributeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AttributeResponse
}

// Status returns HTTPResponse.Status
func (r CreateAttributeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAttributeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttributeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttributeResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAttributeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttributeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttributeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttributeResponse
}

// Status returns HTTPResponse.Status
func (r GetAttributeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttributeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttributeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttributeResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAttributeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttributeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAutomationRulesetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RulesetResponse
}

// Status returns HTTPResponse.Status
func (r ListAutomationRulesetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAutomationRulesetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAutomationRulesetAndRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationRulesetWithRulesResponse
}

// Status returns HTTPResponse.Status
func (r CreateAutomationRulesetAndRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAutomationRulesetAndRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAutomationRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteAutomationRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAutomationRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutomationRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RulesetResponse
}

// Status returns HTTPResponse.Status
func (r GetAutomationRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutomationRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAutomationRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RulesetResponse
}

// Status returns HTTPResponse.Status
func (r PatchAutomationRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAutomationRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAutomationRulesetAndRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationRulesetWithRulesResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAutomationRulesetAndRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAutomationRulesetAndRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAutomationRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AutomationRuleResponse
}

// Status returns HTTPResponse.Status
func (r ListAutomationRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAutomationRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAutomationRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationRuleResponse
}

// Status returns HTTPResponse.Status
func (r CreateAutomationRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAutomationRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAutomationRulesSequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SequencesRequest
}

// Status returns HTTPResponse.Status
func (r UpdateAutomationRulesSequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAutomationRulesSequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAutomationRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteAutomationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAutomationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutomationRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationRuleResponse
}

// Status returns HTTPResponse.Status
func (r GetAutomationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutomationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAutomationRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationRuleResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAutomationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAutomationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCarrierAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CarrierAccountEndpointObject
}

// Status returns HTTPResponse.Status
func (r ListCarrierAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCarrierAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCarrierAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CarrierAccountEndpointObject
}

// Status returns HTTPResponse.Status
func (r CreateCarrierAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCarrierAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCarrierAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CarrierAccountEndpointObject
}

// Status returns HTTPResponse.Status
func (r DeleteCarrierAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCarrierAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCarrierAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CarrierAccountEndpointObject
}

// Status returns HTTPResponse.Status
func (r GetCarrierAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCarrierAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCarrierAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CarrierAccountEndpointObject
}

// Status returns HTTPResponse.Status
func (r UpdateCarrierAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCarrierAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShippingRatesResponse
}

// Status returns HTTPResponse.Status
func (r GetShippingRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListManifestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ManifestResponse
}

// Status returns HTTPResponse.Status
func (r ListManifestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListManifestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ManifestResponse
}

// Status returns HTTPResponse.Status
func (r CreateManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManifestResponse
}

// Status returns HTTPResponse.Status
func (r DeleteManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManifestResponse
}

// Status returns HTTPResponse.Status
func (r GetManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r CancelManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r RetryManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShipManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ShipManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShipManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceLevelRulesetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RulesetResponse
}

// Status returns HTTPResponse.Status
func (r ListServiceLevelRulesetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceLevelRulesetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceLevelRulesetAndRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceLevelRulesetWithRulesResponse
}

// Status returns HTTPResponse.Status
func (r CreateServiceLevelRulesetAndRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceLevelRulesetAndRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceLevelRulesSequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SequencesRequest
}

// Status returns HTTPResponse.Status
func (r UpdateServiceLevelRulesSequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceLevelRulesSequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceLevelRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteServiceLevelRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceLevelRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceLevelRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceLevelRuleResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceLevelRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceLevelRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceLevelRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceLevelRuleResponse
}

// Status returns HTTPResponse.Status
func (r UpdateServiceLevelRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceLevelRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceLevelRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteServiceLevelRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceLevelRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceLevelRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RulesetResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceLevelRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceLevelRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchServiceLevelRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RulesetResponse
}

// Status returns HTTPResponse.Status
func (r PatchServiceLevelRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchServiceLevelRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceLevelRulesetAndRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceLevelRulesetWithRulesResponse
}

// Status returns HTTPResponse.Status
func (r UpdateServiceLevelRulesetAndRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceLevelRulesetAndRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceLevelRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ServiceLevelRuleResponse
}

// Status returns HTTPResponse.Status
func (r ListServiceLevelRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceLevelRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceLevelRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceLevelRuleResponse
}

// Status returns HTTPResponse.Status
func (r CreateServiceLevelRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceLevelRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListShipmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ShipmentObject
}

// Status returns HTTPResponse.Status
func (r ListShipmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListShipmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
	JSON400      *CreateShipmentErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBulkStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BulkShipmentStatusResponse
}

// Status returns HTTPResponse.Status
func (r GetBulkStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBulkStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
	JSON404      *CreateShipmentErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShipmentPatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
	JSON400      *struct {
		Errors    []string `json:"errors"`
		Status    string   `json:"status"`
		Timestamp string   `json:"timestamp"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateShipmentPatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShipmentPatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
	JSON400      *struct {
		Errors    []string `json:"errors"`
		Status    string   `json:"status"`
		Timestamp string   `json:"timestamp"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
	JSON400      *struct {
		Errors    *[]string `json:"errors,omitempty"`
		Status    *string   `json:"status,omitempty"`
		Timestamp *string   `json:"timestamp,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CancelShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
	JSON400      *struct {
		Errors    []string `json:"errors"`
		Status    string   `json:"status"`
		Timestamp string   `json:"timestamp"`
	}
}

// Status returns HTTPResponse.Status
func (r ConfirmShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EstimateShippingCostForShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
}

// Status returns HTTPResponse.Status
func (r EstimateShippingCostForShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EstimateShippingCostForShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Awb *string `json:"awb,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RefreshLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateParcelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
}

// Status returns HTTPResponse.Status
func (r UpdateParcelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateParcelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadyToShipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
}

// Status returns HTTPResponse.Status
func (r ReadyToShipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadyToShipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReassignShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
}

// Status returns HTTPResponse.Status
func (r ReassignShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReassignShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReprocessShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
}

// Status returns HTTPResponse.Status
func (r ReprocessShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReprocessShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCollectionScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
}

// Status returns HTTPResponse.Status
func (r UpdateCollectionScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCollectionScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDeliveryPromiseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
}

// Status returns HTTPResponse.Status
func (r UpdateDeliveryPromiseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDeliveryPromiseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDeliveryScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
}

// Status returns HTTPResponse.Status
func (r UpdateDeliveryScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDeliveryScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentObject
	JSON400      *struct {
		Errors    *[]string `json:"errors,omitempty"`
		Status    *string   `json:"status,omitempty"`
		Timestamp *string   `json:"timestamp,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAttrbutesWithResponse request returning *ListAttrbutesResponse
func (c *ClientWithResponses) ListAttrbutesWithResponse(ctx context.Context, params *ListAttrbutesParams, reqEditors ...RequestEditorFn) (*ListAttrbutesResponse, error) {
	rsp, err := c.ListAttrbutes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttrbutesResponse(rsp)
}

// CreateAttributeWithBodyWithResponse request with arbitrary body returning *CreateAttributeResponse
func (c *ClientWithResponses) CreateAttributeWithBodyWithResponse(ctx context.Context, params *CreateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttributeResponse, error) {
	rsp, err := c.CreateAttributeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttributeResponse(rsp)
}

func (c *ClientWithResponses) CreateAttributeWithResponse(ctx context.Context, params *CreateAttributeParams, body CreateAttributeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAttributeResponse, error) {
	rsp, err := c.CreateAttribute(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttributeResponse(rsp)
}

// DeleteAttributeWithResponse request returning *DeleteAttributeResponse
func (c *ClientWithResponses) DeleteAttributeWithResponse(ctx context.Context, attributeId string, params *DeleteAttributeParams, reqEditors ...RequestEditorFn) (*DeleteAttributeResponse, error) {
	rsp, err := c.DeleteAttribute(ctx, attributeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttributeResponse(rsp)
}

// GetAttributeWithResponse request returning *GetAttributeResponse
func (c *ClientWithResponses) GetAttributeWithResponse(ctx context.Context, attributeId string, params *GetAttributeParams, reqEditors ...RequestEditorFn) (*GetAttributeResponse, error) {
	rsp, err := c.GetAttribute(ctx, attributeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttributeResponse(rsp)
}

// UpdateAttributeWithBodyWithResponse request with arbitrary body returning *UpdateAttributeResponse
func (c *ClientWithResponses) UpdateAttributeWithBodyWithResponse(ctx context.Context, attributeId string, params *UpdateAttributeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttributeResponse, error) {
	rsp, err := c.UpdateAttributeWithBody(ctx, attributeId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttributeResponse(rsp)
}

func (c *ClientWithResponses) UpdateAttributeWithResponse(ctx context.Context, attributeId string, params *UpdateAttributeParams, body UpdateAttributeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttributeResponse, error) {
	rsp, err := c.UpdateAttribute(ctx, attributeId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttributeResponse(rsp)
}

// ListAutomationRulesetsWithResponse request returning *ListAutomationRulesetsResponse
func (c *ClientWithResponses) ListAutomationRulesetsWithResponse(ctx context.Context, params *ListAutomationRulesetsParams, reqEditors ...RequestEditorFn) (*ListAutomationRulesetsResponse, error) {
	rsp, err := c.ListAutomationRulesets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAutomationRulesetsResponse(rsp)
}

// CreateAutomationRulesetAndRulesWithBodyWithResponse request with arbitrary body returning *CreateAutomationRulesetAndRulesResponse
func (c *ClientWithResponses) CreateAutomationRulesetAndRulesWithBodyWithResponse(ctx context.Context, params *CreateAutomationRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAutomationRulesetAndRulesResponse, error) {
	rsp, err := c.CreateAutomationRulesetAndRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAutomationRulesetAndRulesResponse(rsp)
}

func (c *ClientWithResponses) CreateAutomationRulesetAndRulesWithResponse(ctx context.Context, params *CreateAutomationRulesetAndRulesParams, body CreateAutomationRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAutomationRulesetAndRulesResponse, error) {
	rsp, err := c.CreateAutomationRulesetAndRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAutomationRulesetAndRulesResponse(rsp)
}

// DeleteAutomationRulesetWithResponse request returning *DeleteAutomationRulesetResponse
func (c *ClientWithResponses) DeleteAutomationRulesetWithResponse(ctx context.Context, automationRulesetId string, params *DeleteAutomationRulesetParams, reqEditors ...RequestEditorFn) (*DeleteAutomationRulesetResponse, error) {
	rsp, err := c.DeleteAutomationRuleset(ctx, automationRulesetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAutomationRulesetResponse(rsp)
}

// GetAutomationRulesetWithResponse request returning *GetAutomationRulesetResponse
func (c *ClientWithResponses) GetAutomationRulesetWithResponse(ctx context.Context, automationRulesetId string, params *GetAutomationRulesetParams, reqEditors ...RequestEditorFn) (*GetAutomationRulesetResponse, error) {
	rsp, err := c.GetAutomationRuleset(ctx, automationRulesetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutomationRulesetResponse(rsp)
}

// PatchAutomationRulesetWithBodyWithResponse request with arbitrary body returning *PatchAutomationRulesetResponse
func (c *ClientWithResponses) PatchAutomationRulesetWithBodyWithResponse(ctx context.Context, automationRulesetId string, params *PatchAutomationRulesetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAutomationRulesetResponse, error) {
	rsp, err := c.PatchAutomationRulesetWithBody(ctx, automationRulesetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAutomationRulesetResponse(rsp)
}

func (c *ClientWithResponses) PatchAutomationRulesetWithResponse(ctx context.Context, automationRulesetId string, params *PatchAutomationRulesetParams, body PatchAutomationRulesetJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAutomationRulesetResponse, error) {
	rsp, err := c.PatchAutomationRuleset(ctx, automationRulesetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAutomationRulesetResponse(rsp)
}

// UpdateAutomationRulesetAndRulesWithBodyWithResponse request with arbitrary body returning *UpdateAutomationRulesetAndRulesResponse
func (c *ClientWithResponses) UpdateAutomationRulesetAndRulesWithBodyWithResponse(ctx context.Context, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationRulesetAndRulesResponse, error) {
	rsp, err := c.UpdateAutomationRulesetAndRulesWithBody(ctx, automationRulesetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationRulesetAndRulesResponse(rsp)
}

func (c *ClientWithResponses) UpdateAutomationRulesetAndRulesWithResponse(ctx context.Context, automationRulesetId string, params *UpdateAutomationRulesetAndRulesParams, body UpdateAutomationRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationRulesetAndRulesResponse, error) {
	rsp, err := c.UpdateAutomationRulesetAndRules(ctx, automationRulesetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationRulesetAndRulesResponse(rsp)
}

// ListAutomationRulesWithResponse request returning *ListAutomationRulesResponse
func (c *ClientWithResponses) ListAutomationRulesWithResponse(ctx context.Context, automationRulesetId string, params *ListAutomationRulesParams, reqEditors ...RequestEditorFn) (*ListAutomationRulesResponse, error) {
	rsp, err := c.ListAutomationRules(ctx, automationRulesetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAutomationRulesResponse(rsp)
}

// CreateAutomationRulesWithBodyWithResponse request with arbitrary body returning *CreateAutomationRulesResponse
func (c *ClientWithResponses) CreateAutomationRulesWithBodyWithResponse(ctx context.Context, automationRulesetId string, params *CreateAutomationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAutomationRulesResponse, error) {
	rsp, err := c.CreateAutomationRulesWithBody(ctx, automationRulesetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAutomationRulesResponse(rsp)
}

func (c *ClientWithResponses) CreateAutomationRulesWithResponse(ctx context.Context, automationRulesetId string, params *CreateAutomationRulesParams, body CreateAutomationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAutomationRulesResponse, error) {
	rsp, err := c.CreateAutomationRules(ctx, automationRulesetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAutomationRulesResponse(rsp)
}

// UpdateAutomationRulesSequenceWithBodyWithResponse request with arbitrary body returning *UpdateAutomationRulesSequenceResponse
func (c *ClientWithResponses) UpdateAutomationRulesSequenceWithBodyWithResponse(ctx context.Context, rulesetId string, params *UpdateAutomationRulesSequenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationRulesSequenceResponse, error) {
	rsp, err := c.UpdateAutomationRulesSequenceWithBody(ctx, rulesetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationRulesSequenceResponse(rsp)
}

func (c *ClientWithResponses) UpdateAutomationRulesSequenceWithResponse(ctx context.Context, rulesetId string, params *UpdateAutomationRulesSequenceParams, body UpdateAutomationRulesSequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationRulesSequenceResponse, error) {
	rsp, err := c.UpdateAutomationRulesSequence(ctx, rulesetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationRulesSequenceResponse(rsp)
}

// DeleteAutomationRuleWithResponse request returning *DeleteAutomationRuleResponse
func (c *ClientWithResponses) DeleteAutomationRuleWithResponse(ctx context.Context, rulesetId string, automationRuleId string, params *DeleteAutomationRuleParams, reqEditors ...RequestEditorFn) (*DeleteAutomationRuleResponse, error) {
	rsp, err := c.DeleteAutomationRule(ctx, rulesetId, automationRuleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAutomationRuleResponse(rsp)
}

// GetAutomationRuleWithResponse request returning *GetAutomationRuleResponse
func (c *ClientWithResponses) GetAutomationRuleWithResponse(ctx context.Context, rulesetId string, automationRuleId string, params *GetAutomationRuleParams, reqEditors ...RequestEditorFn) (*GetAutomationRuleResponse, error) {
	rsp, err := c.GetAutomationRule(ctx, rulesetId, automationRuleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutomationRuleResponse(rsp)
}

// UpdateAutomationRuleWithBodyWithResponse request with arbitrary body returning *UpdateAutomationRuleResponse
func (c *ClientWithResponses) UpdateAutomationRuleWithBodyWithResponse(ctx context.Context, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationRuleResponse, error) {
	rsp, err := c.UpdateAutomationRuleWithBody(ctx, rulesetId, automationRuleId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateAutomationRuleWithResponse(ctx context.Context, rulesetId string, automationRuleId string, params *UpdateAutomationRuleParams, body UpdateAutomationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationRuleResponse, error) {
	rsp, err := c.UpdateAutomationRule(ctx, rulesetId, automationRuleId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationRuleResponse(rsp)
}

// ListCarrierAccountsWithResponse request returning *ListCarrierAccountsResponse
func (c *ClientWithResponses) ListCarrierAccountsWithResponse(ctx context.Context, params *ListCarrierAccountsParams, reqEditors ...RequestEditorFn) (*ListCarrierAccountsResponse, error) {
	rsp, err := c.ListCarrierAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCarrierAccountsResponse(rsp)
}

// CreateCarrierAccountWithBodyWithResponse request with arbitrary body returning *CreateCarrierAccountResponse
func (c *ClientWithResponses) CreateCarrierAccountWithBodyWithResponse(ctx context.Context, params *CreateCarrierAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCarrierAccountResponse, error) {
	rsp, err := c.CreateCarrierAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCarrierAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateCarrierAccountWithResponse(ctx context.Context, params *CreateCarrierAccountParams, body CreateCarrierAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCarrierAccountResponse, error) {
	rsp, err := c.CreateCarrierAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCarrierAccountResponse(rsp)
}

// DeleteCarrierAccountWithResponse request returning *DeleteCarrierAccountResponse
func (c *ClientWithResponses) DeleteCarrierAccountWithResponse(ctx context.Context, carrierAccountId string, params *DeleteCarrierAccountParams, reqEditors ...RequestEditorFn) (*DeleteCarrierAccountResponse, error) {
	rsp, err := c.DeleteCarrierAccount(ctx, carrierAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCarrierAccountResponse(rsp)
}

// GetCarrierAccountWithResponse request returning *GetCarrierAccountResponse
func (c *ClientWithResponses) GetCarrierAccountWithResponse(ctx context.Context, carrierAccountId string, params *GetCarrierAccountParams, reqEditors ...RequestEditorFn) (*GetCarrierAccountResponse, error) {
	rsp, err := c.GetCarrierAccount(ctx, carrierAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCarrierAccountResponse(rsp)
}

// UpdateCarrierAccountWithBodyWithResponse request with arbitrary body returning *UpdateCarrierAccountResponse
func (c *ClientWithResponses) UpdateCarrierAccountWithBodyWithResponse(ctx context.Context, carrierAccountId string, params *UpdateCarrierAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCarrierAccountResponse, error) {
	rsp, err := c.UpdateCarrierAccountWithBody(ctx, carrierAccountId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCarrierAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateCarrierAccountWithResponse(ctx context.Context, carrierAccountId string, params *UpdateCarrierAccountParams, body UpdateCarrierAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCarrierAccountResponse, error) {
	rsp, err := c.UpdateCarrierAccount(ctx, carrierAccountId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCarrierAccountResponse(rsp)
}

// GetShippingRatesWithBodyWithResponse request with arbitrary body returning *GetShippingRatesResponse
func (c *ClientWithResponses) GetShippingRatesWithBodyWithResponse(ctx context.Context, params *GetShippingRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetShippingRatesResponse, error) {
	rsp, err := c.GetShippingRatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingRatesResponse(rsp)
}

func (c *ClientWithResponses) GetShippingRatesWithResponse(ctx context.Context, params *GetShippingRatesParams, body GetShippingRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetShippingRatesResponse, error) {
	rsp, err := c.GetShippingRates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingRatesResponse(rsp)
}

// ListManifestsWithResponse request returning *ListManifestsResponse
func (c *ClientWithResponses) ListManifestsWithResponse(ctx context.Context, params *ListManifestsParams, reqEditors ...RequestEditorFn) (*ListManifestsResponse, error) {
	rsp, err := c.ListManifests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListManifestsResponse(rsp)
}

// CreateManifestWithBodyWithResponse request with arbitrary body returning *CreateManifestResponse
func (c *ClientWithResponses) CreateManifestWithBodyWithResponse(ctx context.Context, params *CreateManifestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManifestResponse, error) {
	rsp, err := c.CreateManifestWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManifestResponse(rsp)
}

func (c *ClientWithResponses) CreateManifestWithResponse(ctx context.Context, params *CreateManifestParams, body CreateManifestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManifestResponse, error) {
	rsp, err := c.CreateManifest(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManifestResponse(rsp)
}

// DeleteManifestWithResponse request returning *DeleteManifestResponse
func (c *ClientWithResponses) DeleteManifestWithResponse(ctx context.Context, manifestId string, params *DeleteManifestParams, reqEditors ...RequestEditorFn) (*DeleteManifestResponse, error) {
	rsp, err := c.DeleteManifest(ctx, manifestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManifestResponse(rsp)
}

// GetManifestWithResponse request returning *GetManifestResponse
func (c *ClientWithResponses) GetManifestWithResponse(ctx context.Context, manifestId string, params *GetManifestParams, reqEditors ...RequestEditorFn) (*GetManifestResponse, error) {
	rsp, err := c.GetManifest(ctx, manifestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManifestResponse(rsp)
}

// CancelManifestWithResponse request returning *CancelManifestResponse
func (c *ClientWithResponses) CancelManifestWithResponse(ctx context.Context, manifestId string, params *CancelManifestParams, reqEditors ...RequestEditorFn) (*CancelManifestResponse, error) {
	rsp, err := c.CancelManifest(ctx, manifestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelManifestResponse(rsp)
}

// RetryManifestWithResponse request returning *RetryManifestResponse
func (c *ClientWithResponses) RetryManifestWithResponse(ctx context.Context, manifestId string, params *RetryManifestParams, reqEditors ...RequestEditorFn) (*RetryManifestResponse, error) {
	rsp, err := c.RetryManifest(ctx, manifestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryManifestResponse(rsp)
}

// ShipManifestWithResponse request returning *ShipManifestResponse
func (c *ClientWithResponses) ShipManifestWithResponse(ctx context.Context, manifestId string, params *ShipManifestParams, reqEditors ...RequestEditorFn) (*ShipManifestResponse, error) {
	rsp, err := c.ShipManifest(ctx, manifestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShipManifestResponse(rsp)
}

// ListServiceLevelRulesetsWithResponse request returning *ListServiceLevelRulesetsResponse
func (c *ClientWithResponses) ListServiceLevelRulesetsWithResponse(ctx context.Context, params *ListServiceLevelRulesetsParams, reqEditors ...RequestEditorFn) (*ListServiceLevelRulesetsResponse, error) {
	rsp, err := c.ListServiceLevelRulesets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceLevelRulesetsResponse(rsp)
}

// CreateServiceLevelRulesetAndRulesWithBodyWithResponse request with arbitrary body returning *CreateServiceLevelRulesetAndRulesResponse
func (c *ClientWithResponses) CreateServiceLevelRulesetAndRulesWithBodyWithResponse(ctx context.Context, params *CreateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceLevelRulesetAndRulesResponse, error) {
	rsp, err := c.CreateServiceLevelRulesetAndRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceLevelRulesetAndRulesResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceLevelRulesetAndRulesWithResponse(ctx context.Context, params *CreateServiceLevelRulesetAndRulesParams, body CreateServiceLevelRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceLevelRulesetAndRulesResponse, error) {
	rsp, err := c.CreateServiceLevelRulesetAndRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceLevelRulesetAndRulesResponse(rsp)
}

// UpdateServiceLevelRulesSequenceWithBodyWithResponse request with arbitrary body returning *UpdateServiceLevelRulesSequenceResponse
func (c *ClientWithResponses) UpdateServiceLevelRulesSequenceWithBodyWithResponse(ctx context.Context, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRulesSequenceResponse, error) {
	rsp, err := c.UpdateServiceLevelRulesSequenceWithBody(ctx, rulesetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceLevelRulesSequenceResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceLevelRulesSequenceWithResponse(ctx context.Context, rulesetId string, params *UpdateServiceLevelRulesSequenceParams, body UpdateServiceLevelRulesSequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRulesSequenceResponse, error) {
	rsp, err := c.UpdateServiceLevelRulesSequence(ctx, rulesetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceLevelRulesSequenceResponse(rsp)
}

// DeleteServiceLevelRuleWithResponse request returning *DeleteServiceLevelRuleResponse
func (c *ClientWithResponses) DeleteServiceLevelRuleWithResponse(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *DeleteServiceLevelRuleParams, reqEditors ...RequestEditorFn) (*DeleteServiceLevelRuleResponse, error) {
	rsp, err := c.DeleteServiceLevelRule(ctx, rulesetId, serviceLevelRuleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceLevelRuleResponse(rsp)
}

// GetServiceLevelRuleWithResponse request returning *GetServiceLevelRuleResponse
func (c *ClientWithResponses) GetServiceLevelRuleWithResponse(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *GetServiceLevelRuleParams, reqEditors ...RequestEditorFn) (*GetServiceLevelRuleResponse, error) {
	rsp, err := c.GetServiceLevelRule(ctx, rulesetId, serviceLevelRuleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceLevelRuleResponse(rsp)
}

// UpdateServiceLevelRuleWithBodyWithResponse request with arbitrary body returning *UpdateServiceLevelRuleResponse
func (c *ClientWithResponses) UpdateServiceLevelRuleWithBodyWithResponse(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRuleResponse, error) {
	rsp, err := c.UpdateServiceLevelRuleWithBody(ctx, rulesetId, serviceLevelRuleId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceLevelRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceLevelRuleWithResponse(ctx context.Context, rulesetId string, serviceLevelRuleId string, params *UpdateServiceLevelRuleParams, body UpdateServiceLevelRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRuleResponse, error) {
	rsp, err := c.UpdateServiceLevelRule(ctx, rulesetId, serviceLevelRuleId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceLevelRuleResponse(rsp)
}

// DeleteServiceLevelRulesetWithResponse request returning *DeleteServiceLevelRulesetResponse
func (c *ClientWithResponses) DeleteServiceLevelRulesetWithResponse(ctx context.Context, serviceLevelRulesetId string, params *DeleteServiceLevelRulesetParams, reqEditors ...RequestEditorFn) (*DeleteServiceLevelRulesetResponse, error) {
	rsp, err := c.DeleteServiceLevelRuleset(ctx, serviceLevelRulesetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceLevelRulesetResponse(rsp)
}

// GetServiceLevelRulesetWithResponse request returning *GetServiceLevelRulesetResponse
func (c *ClientWithResponses) GetServiceLevelRulesetWithResponse(ctx context.Context, serviceLevelRulesetId string, params *GetServiceLevelRulesetParams, reqEditors ...RequestEditorFn) (*GetServiceLevelRulesetResponse, error) {
	rsp, err := c.GetServiceLevelRuleset(ctx, serviceLevelRulesetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceLevelRulesetResponse(rsp)
}

// PatchServiceLevelRulesetWithBodyWithResponse request with arbitrary body returning *PatchServiceLevelRulesetResponse
func (c *ClientWithResponses) PatchServiceLevelRulesetWithBodyWithResponse(ctx context.Context, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchServiceLevelRulesetResponse, error) {
	rsp, err := c.PatchServiceLevelRulesetWithBody(ctx, serviceLevelRulesetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchServiceLevelRulesetResponse(rsp)
}

func (c *ClientWithResponses) PatchServiceLevelRulesetWithResponse(ctx context.Context, serviceLevelRulesetId string, params *PatchServiceLevelRulesetParams, body PatchServiceLevelRulesetJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchServiceLevelRulesetResponse, error) {
	rsp, err := c.PatchServiceLevelRuleset(ctx, serviceLevelRulesetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchServiceLevelRulesetResponse(rsp)
}

// UpdateServiceLevelRulesetAndRulesWithBodyWithResponse request with arbitrary body returning *UpdateServiceLevelRulesetAndRulesResponse
func (c *ClientWithResponses) UpdateServiceLevelRulesetAndRulesWithBodyWithResponse(ctx context.Context, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRulesetAndRulesResponse, error) {
	rsp, err := c.UpdateServiceLevelRulesetAndRulesWithBody(ctx, serviceLevelRulesetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceLevelRulesetAndRulesResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceLevelRulesetAndRulesWithResponse(ctx context.Context, serviceLevelRulesetId string, params *UpdateServiceLevelRulesetAndRulesParams, body UpdateServiceLevelRulesetAndRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceLevelRulesetAndRulesResponse, error) {
	rsp, err := c.UpdateServiceLevelRulesetAndRules(ctx, serviceLevelRulesetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceLevelRulesetAndRulesResponse(rsp)
}

// ListServiceLevelRulesWithResponse request returning *ListServiceLevelRulesResponse
func (c *ClientWithResponses) ListServiceLevelRulesWithResponse(ctx context.Context, serviceLevelRulesetId string, params *ListServiceLevelRulesParams, reqEditors ...RequestEditorFn) (*ListServiceLevelRulesResponse, error) {
	rsp, err := c.ListServiceLevelRules(ctx, serviceLevelRulesetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceLevelRulesResponse(rsp)
}

// CreateServiceLevelRulesWithBodyWithResponse request with arbitrary body returning *CreateServiceLevelRulesResponse
func (c *ClientWithResponses) CreateServiceLevelRulesWithBodyWithResponse(ctx context.Context, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceLevelRulesResponse, error) {
	rsp, err := c.CreateServiceLevelRulesWithBody(ctx, serviceLevelRulesetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceLevelRulesResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceLevelRulesWithResponse(ctx context.Context, serviceLevelRulesetId string, params *CreateServiceLevelRulesParams, body CreateServiceLevelRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceLevelRulesResponse, error) {
	rsp, err := c.CreateServiceLevelRules(ctx, serviceLevelRulesetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceLevelRulesResponse(rsp)
}

// ListShipmentsWithResponse request returning *ListShipmentsResponse
func (c *ClientWithResponses) ListShipmentsWithResponse(ctx context.Context, params *ListShipmentsParams, reqEditors ...RequestEditorFn) (*ListShipmentsResponse, error) {
	rsp, err := c.ListShipments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListShipmentsResponse(rsp)
}

// CreateShipmentWithBodyWithResponse request with arbitrary body returning *CreateShipmentResponse
func (c *ClientWithResponses) CreateShipmentWithBodyWithResponse(ctx context.Context, params *CreateShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateShipmentResponse, error) {
	rsp, err := c.CreateShipmentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateShipmentResponse(rsp)
}

func (c *ClientWithResponses) CreateShipmentWithResponse(ctx context.Context, params *CreateShipmentParams, body CreateShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateShipmentResponse, error) {
	rsp, err := c.CreateShipment(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateShipmentResponse(rsp)
}

// GetBulkStatusWithResponse request returning *GetBulkStatusResponse
func (c *ClientWithResponses) GetBulkStatusWithResponse(ctx context.Context, params *GetBulkStatusParams, reqEditors ...RequestEditorFn) (*GetBulkStatusResponse, error) {
	rsp, err := c.GetBulkStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBulkStatusResponse(rsp)
}

// GetShipmentWithResponse request returning *GetShipmentResponse
func (c *ClientWithResponses) GetShipmentWithResponse(ctx context.Context, shipmentId string, params *GetShipmentParams, reqEditors ...RequestEditorFn) (*GetShipmentResponse, error) {
	rsp, err := c.GetShipment(ctx, shipmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentResponse(rsp)
}

// UpdateShipmentPatchWithBodyWithResponse request with arbitrary body returning *UpdateShipmentPatchResponse
func (c *ClientWithResponses) UpdateShipmentPatchWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateShipmentPatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShipmentPatchResponse, error) {
	rsp, err := c.UpdateShipmentPatchWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentPatchResponse(rsp)
}

func (c *ClientWithResponses) UpdateShipmentPatchWithResponse(ctx context.Context, shipmentId string, params *UpdateShipmentPatchParams, body UpdateShipmentPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShipmentPatchResponse, error) {
	rsp, err := c.UpdateShipmentPatch(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentPatchResponse(rsp)
}

// UpdateShipmentWithBodyWithResponse request with arbitrary body returning *UpdateShipmentResponse
func (c *ClientWithResponses) UpdateShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShipmentResponse, error) {
	rsp, err := c.UpdateShipmentWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentResponse(rsp)
}

func (c *ClientWithResponses) UpdateShipmentWithResponse(ctx context.Context, shipmentId string, params *UpdateShipmentParams, body UpdateShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShipmentResponse, error) {
	rsp, err := c.UpdateShipment(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentResponse(rsp)
}

// CancelShipmentWithBodyWithResponse request with arbitrary body returning *CancelShipmentResponse
func (c *ClientWithResponses) CancelShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *CancelShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelShipmentResponse, error) {
	rsp, err := c.CancelShipmentWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelShipmentResponse(rsp)
}

func (c *ClientWithResponses) CancelShipmentWithResponse(ctx context.Context, shipmentId string, params *CancelShipmentParams, body CancelShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelShipmentResponse, error) {
	rsp, err := c.CancelShipment(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelShipmentResponse(rsp)
}

// ConfirmShipmentWithBodyWithResponse request with arbitrary body returning *ConfirmShipmentResponse
func (c *ClientWithResponses) ConfirmShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *ConfirmShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmShipmentResponse, error) {
	rsp, err := c.ConfirmShipmentWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmShipmentResponse(rsp)
}

func (c *ClientWithResponses) ConfirmShipmentWithResponse(ctx context.Context, shipmentId string, params *ConfirmShipmentParams, body ConfirmShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmShipmentResponse, error) {
	rsp, err := c.ConfirmShipment(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmShipmentResponse(rsp)
}

// EstimateShippingCostForShipmentWithResponse request returning *EstimateShippingCostForShipmentResponse
func (c *ClientWithResponses) EstimateShippingCostForShipmentWithResponse(ctx context.Context, shipmentId string, params *EstimateShippingCostForShipmentParams, reqEditors ...RequestEditorFn) (*EstimateShippingCostForShipmentResponse, error) {
	rsp, err := c.EstimateShippingCostForShipment(ctx, shipmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEstimateShippingCostForShipmentResponse(rsp)
}

// RefreshLabelWithResponse request returning *RefreshLabelResponse
func (c *ClientWithResponses) RefreshLabelWithResponse(ctx context.Context, shipmentId string, params *RefreshLabelParams, reqEditors ...RequestEditorFn) (*RefreshLabelResponse, error) {
	rsp, err := c.RefreshLabel(ctx, shipmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshLabelResponse(rsp)
}

// UpdateParcelsWithBodyWithResponse request with arbitrary body returning *UpdateParcelsResponse
func (c *ClientWithResponses) UpdateParcelsWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateParcelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateParcelsResponse, error) {
	rsp, err := c.UpdateParcelsWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateParcelsResponse(rsp)
}

func (c *ClientWithResponses) UpdateParcelsWithResponse(ctx context.Context, shipmentId string, params *UpdateParcelsParams, body UpdateParcelsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateParcelsResponse, error) {
	rsp, err := c.UpdateParcels(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateParcelsResponse(rsp)
}

// ReadyToShipWithBodyWithResponse request with arbitrary body returning *ReadyToShipResponse
func (c *ClientWithResponses) ReadyToShipWithBodyWithResponse(ctx context.Context, shipmentId string, params *ReadyToShipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadyToShipResponse, error) {
	rsp, err := c.ReadyToShipWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadyToShipResponse(rsp)
}

func (c *ClientWithResponses) ReadyToShipWithResponse(ctx context.Context, shipmentId string, params *ReadyToShipParams, body ReadyToShipJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadyToShipResponse, error) {
	rsp, err := c.ReadyToShip(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadyToShipResponse(rsp)
}

// ReassignShipmentWithBodyWithResponse request with arbitrary body returning *ReassignShipmentResponse
func (c *ClientWithResponses) ReassignShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *ReassignShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReassignShipmentResponse, error) {
	rsp, err := c.ReassignShipmentWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReassignShipmentResponse(rsp)
}

func (c *ClientWithResponses) ReassignShipmentWithResponse(ctx context.Context, shipmentId string, params *ReassignShipmentParams, body ReassignShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReassignShipmentResponse, error) {
	rsp, err := c.ReassignShipment(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReassignShipmentResponse(rsp)
}

// ReprocessShipmentWithBodyWithResponse request with arbitrary body returning *ReprocessShipmentResponse
func (c *ClientWithResponses) ReprocessShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, params *ReprocessShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReprocessShipmentResponse, error) {
	rsp, err := c.ReprocessShipmentWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReprocessShipmentResponse(rsp)
}

func (c *ClientWithResponses) ReprocessShipmentWithResponse(ctx context.Context, shipmentId string, params *ReprocessShipmentParams, body ReprocessShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReprocessShipmentResponse, error) {
	rsp, err := c.ReprocessShipment(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReprocessShipmentResponse(rsp)
}

// UpdateCollectionScheduleWithBodyWithResponse request with arbitrary body returning *UpdateCollectionScheduleResponse
func (c *ClientWithResponses) UpdateCollectionScheduleWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateCollectionScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionScheduleResponse, error) {
	rsp, err := c.UpdateCollectionScheduleWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionScheduleResponse(rsp)
}

func (c *ClientWithResponses) UpdateCollectionScheduleWithResponse(ctx context.Context, shipmentId string, params *UpdateCollectionScheduleParams, body UpdateCollectionScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionScheduleResponse, error) {
	rsp, err := c.UpdateCollectionSchedule(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionScheduleResponse(rsp)
}

// UpdateDeliveryPromiseWithBodyWithResponse request with arbitrary body returning *UpdateDeliveryPromiseResponse
func (c *ClientWithResponses) UpdateDeliveryPromiseWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateDeliveryPromiseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeliveryPromiseResponse, error) {
	rsp, err := c.UpdateDeliveryPromiseWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeliveryPromiseResponse(rsp)
}

func (c *ClientWithResponses) UpdateDeliveryPromiseWithResponse(ctx context.Context, shipmentId string, params *UpdateDeliveryPromiseParams, body UpdateDeliveryPromiseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeliveryPromiseResponse, error) {
	rsp, err := c.UpdateDeliveryPromise(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeliveryPromiseResponse(rsp)
}

// UpdateDeliveryScheduleWithBodyWithResponse request with arbitrary body returning *UpdateDeliveryScheduleResponse
func (c *ClientWithResponses) UpdateDeliveryScheduleWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateDeliveryScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeliveryScheduleResponse, error) {
	rsp, err := c.UpdateDeliveryScheduleWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeliveryScheduleResponse(rsp)
}

func (c *ClientWithResponses) UpdateDeliveryScheduleWithResponse(ctx context.Context, shipmentId string, params *UpdateDeliveryScheduleParams, body UpdateDeliveryScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeliveryScheduleResponse, error) {
	rsp, err := c.UpdateDeliverySchedule(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeliveryScheduleResponse(rsp)
}

// UpdateStatusWithBodyWithResponse request with arbitrary body returning *UpdateStatusResponse
func (c *ClientWithResponses) UpdateStatusWithBodyWithResponse(ctx context.Context, shipmentId string, params *UpdateStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStatusResponse, error) {
	rsp, err := c.UpdateStatusWithBody(ctx, shipmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStatusResponse(rsp)
}

func (c *ClientWithResponses) UpdateStatusWithResponse(ctx context.Context, shipmentId string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStatusResponse, error) {
	rsp, err := c.UpdateStatus(ctx, shipmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStatusResponse(rsp)
}

// ParseListAttrbutesResponse parses an HTTP response from a ListAttrbutesWithResponse call
func ParseListAttrbutesResponse(rsp *http.Response) (*ListAttrbutesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttrbutesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttributeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAttributeResponse parses an HTTP response from a CreateAttributeWithResponse call
func ParseCreateAttributeResponse(rsp *http.Response) (*CreateAttributeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAttributeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AttributeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteAttributeResponse parses an HTTP response from a DeleteAttributeWithResponse call
func ParseDeleteAttributeResponse(rsp *http.Response) (*DeleteAttributeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttributeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttributeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAttributeResponse parses an HTTP response from a GetAttributeWithResponse call
func ParseGetAttributeResponse(rsp *http.Response) (*GetAttributeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttributeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttributeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAttributeResponse parses an HTTP response from a UpdateAttributeWithResponse call
func ParseUpdateAttributeResponse(rsp *http.Response) (*UpdateAttributeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttributeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttributeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAutomationRulesetsResponse parses an HTTP response from a ListAutomationRulesetsWithResponse call
func ParseListAutomationRulesetsResponse(rsp *http.Response) (*ListAutomationRulesetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAutomationRulesetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RulesetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAutomationRulesetAndRulesResponse parses an HTTP response from a CreateAutomationRulesetAndRulesWithResponse call
func ParseCreateAutomationRulesetAndRulesResponse(rsp *http.Response) (*CreateAutomationRulesetAndRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAutomationRulesetAndRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationRulesetWithRulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAutomationRulesetResponse parses an HTTP response from a DeleteAutomationRulesetWithResponse call
func ParseDeleteAutomationRulesetResponse(rsp *http.Response) (*DeleteAutomationRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAutomationRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAutomationRulesetResponse parses an HTTP response from a GetAutomationRulesetWithResponse call
func ParseGetAutomationRulesetResponse(rsp *http.Response) (*GetAutomationRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutomationRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RulesetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchAutomationRulesetResponse parses an HTTP response from a PatchAutomationRulesetWithResponse call
func ParsePatchAutomationRulesetResponse(rsp *http.Response) (*PatchAutomationRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAutomationRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RulesetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAutomationRulesetAndRulesResponse parses an HTTP response from a UpdateAutomationRulesetAndRulesWithResponse call
func ParseUpdateAutomationRulesetAndRulesResponse(rsp *http.Response) (*UpdateAutomationRulesetAndRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAutomationRulesetAndRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationRulesetWithRulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAutomationRulesResponse parses an HTTP response from a ListAutomationRulesWithResponse call
func ParseListAutomationRulesResponse(rsp *http.Response) (*ListAutomationRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAutomationRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AutomationRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAutomationRulesResponse parses an HTTP response from a CreateAutomationRulesWithResponse call
func ParseCreateAutomationRulesResponse(rsp *http.Response) (*CreateAutomationRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAutomationRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAutomationRulesSequenceResponse parses an HTTP response from a UpdateAutomationRulesSequenceWithResponse call
func ParseUpdateAutomationRulesSequenceResponse(rsp *http.Response) (*UpdateAutomationRulesSequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAutomationRulesSequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SequencesRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAutomationRuleResponse parses an HTTP response from a DeleteAutomationRuleWithResponse call
func ParseDeleteAutomationRuleResponse(rsp *http.Response) (*DeleteAutomationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAutomationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAutomationRuleResponse parses an HTTP response from a GetAutomationRuleWithResponse call
func ParseGetAutomationRuleResponse(rsp *http.Response) (*GetAutomationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutomationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAutomationRuleResponse parses an HTTP response from a UpdateAutomationRuleWithResponse call
func ParseUpdateAutomationRuleResponse(rsp *http.Response) (*UpdateAutomationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAutomationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCarrierAccountsResponse parses an HTTP response from a ListCarrierAccountsWithResponse call
func ParseListCarrierAccountsResponse(rsp *http.Response) (*ListCarrierAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCarrierAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CarrierAccountEndpointObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCarrierAccountResponse parses an HTTP response from a CreateCarrierAccountWithResponse call
func ParseCreateCarrierAccountResponse(rsp *http.Response) (*CreateCarrierAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCarrierAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CarrierAccountEndpointObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteCarrierAccountResponse parses an HTTP response from a DeleteCarrierAccountWithResponse call
func ParseDeleteCarrierAccountResponse(rsp *http.Response) (*DeleteCarrierAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCarrierAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CarrierAccountEndpointObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCarrierAccountResponse parses an HTTP response from a GetCarrierAccountWithResponse call
func ParseGetCarrierAccountResponse(rsp *http.Response) (*GetCarrierAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCarrierAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CarrierAccountEndpointObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCarrierAccountResponse parses an HTTP response from a UpdateCarrierAccountWithResponse call
func ParseUpdateCarrierAccountResponse(rsp *http.Response) (*UpdateCarrierAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCarrierAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CarrierAccountEndpointObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetShippingRatesResponse parses an HTTP response from a GetShippingRatesWithResponse call
func ParseGetShippingRatesResponse(rsp *http.Response) (*GetShippingRatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShippingRatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListManifestsResponse parses an HTTP response from a ListManifestsWithResponse call
func ParseListManifestsResponse(rsp *http.Response) (*ListManifestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListManifestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ManifestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateManifestResponse parses an HTTP response from a CreateManifestWithResponse call
func ParseCreateManifestResponse(rsp *http.Response) (*CreateManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ManifestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteManifestResponse parses an HTTP response from a DeleteManifestWithResponse call
func ParseDeleteManifestResponse(rsp *http.Response) (*DeleteManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManifestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetManifestResponse parses an HTTP response from a GetManifestWithResponse call
func ParseGetManifestResponse(rsp *http.Response) (*GetManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManifestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelManifestResponse parses an HTTP response from a CancelManifestWithResponse call
func ParseCancelManifestResponse(rsp *http.Response) (*CancelManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetryManifestResponse parses an HTTP response from a RetryManifestWithResponse call
func ParseRetryManifestResponse(rsp *http.Response) (*RetryManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseShipManifestResponse parses an HTTP response from a ShipManifestWithResponse call
func ParseShipManifestResponse(rsp *http.Response) (*ShipManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShipManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListServiceLevelRulesetsResponse parses an HTTP response from a ListServiceLevelRulesetsWithResponse call
func ParseListServiceLevelRulesetsResponse(rsp *http.Response) (*ListServiceLevelRulesetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceLevelRulesetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RulesetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateServiceLevelRulesetAndRulesResponse parses an HTTP response from a CreateServiceLevelRulesetAndRulesWithResponse call
func ParseCreateServiceLevelRulesetAndRulesResponse(rsp *http.Response) (*CreateServiceLevelRulesetAndRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceLevelRulesetAndRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceLevelRulesetWithRulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateServiceLevelRulesSequenceResponse parses an HTTP response from a UpdateServiceLevelRulesSequenceWithResponse call
func ParseUpdateServiceLevelRulesSequenceResponse(rsp *http.Response) (*UpdateServiceLevelRulesSequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceLevelRulesSequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SequencesRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteServiceLevelRuleResponse parses an HTTP response from a DeleteServiceLevelRuleWithResponse call
func ParseDeleteServiceLevelRuleResponse(rsp *http.Response) (*DeleteServiceLevelRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceLevelRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceLevelRuleResponse parses an HTTP response from a GetServiceLevelRuleWithResponse call
func ParseGetServiceLevelRuleResponse(rsp *http.Response) (*GetServiceLevelRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceLevelRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceLevelRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateServiceLevelRuleResponse parses an HTTP response from a UpdateServiceLevelRuleWithResponse call
func ParseUpdateServiceLevelRuleResponse(rsp *http.Response) (*UpdateServiceLevelRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceLevelRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceLevelRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteServiceLevelRulesetResponse parses an HTTP response from a DeleteServiceLevelRulesetWithResponse call
func ParseDeleteServiceLevelRulesetResponse(rsp *http.Response) (*DeleteServiceLevelRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceLevelRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceLevelRulesetResponse parses an HTTP response from a GetServiceLevelRulesetWithResponse call
func ParseGetServiceLevelRulesetResponse(rsp *http.Response) (*GetServiceLevelRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceLevelRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RulesetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchServiceLevelRulesetResponse parses an HTTP response from a PatchServiceLevelRulesetWithResponse call
func ParsePatchServiceLevelRulesetResponse(rsp *http.Response) (*PatchServiceLevelRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchServiceLevelRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RulesetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateServiceLevelRulesetAndRulesResponse parses an HTTP response from a UpdateServiceLevelRulesetAndRulesWithResponse call
func ParseUpdateServiceLevelRulesetAndRulesResponse(rsp *http.Response) (*UpdateServiceLevelRulesetAndRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceLevelRulesetAndRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceLevelRulesetWithRulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListServiceLevelRulesResponse parses an HTTP response from a ListServiceLevelRulesWithResponse call
func ParseListServiceLevelRulesResponse(rsp *http.Response) (*ListServiceLevelRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceLevelRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ServiceLevelRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateServiceLevelRulesResponse parses an HTTP response from a CreateServiceLevelRulesWithResponse call
func ParseCreateServiceLevelRulesResponse(rsp *http.Response) (*CreateServiceLevelRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceLevelRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceLevelRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListShipmentsResponse parses an HTTP response from a ListShipmentsWithResponse call
func ParseListShipmentsResponse(rsp *http.Response) (*ListShipmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListShipmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateShipmentResponse parses an HTTP response from a CreateShipmentWithResponse call
func ParseCreateShipmentResponse(rsp *http.Response) (*CreateShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreateShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBulkStatusResponse parses an HTTP response from a GetBulkStatusWithResponse call
func ParseGetBulkStatusResponse(rsp *http.Response) (*GetBulkStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBulkStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BulkShipmentStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetShipmentResponse parses an HTTP response from a GetShipmentWithResponse call
func ParseGetShipmentResponse(rsp *http.Response) (*GetShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreateShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateShipmentPatchResponse parses an HTTP response from a UpdateShipmentPatchWithResponse call
func ParseUpdateShipmentPatchResponse(rsp *http.Response) (*UpdateShipmentPatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShipmentPatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors    []string `json:"errors"`
			Status    string   `json:"status"`
			Timestamp string   `json:"timestamp"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateShipmentResponse parses an HTTP response from a UpdateShipmentWithResponse call
func ParseUpdateShipmentResponse(rsp *http.Response) (*UpdateShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors    []string `json:"errors"`
			Status    string   `json:"status"`
			Timestamp string   `json:"timestamp"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCancelShipmentResponse parses an HTTP response from a CancelShipmentWithResponse call
func ParseCancelShipmentResponse(rsp *http.Response) (*CancelShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors    *[]string `json:"errors,omitempty"`
			Status    *string   `json:"status,omitempty"`
			Timestamp *string   `json:"timestamp,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseConfirmShipmentResponse parses an HTTP response from a ConfirmShipmentWithResponse call
func ParseConfirmShipmentResponse(rsp *http.Response) (*ConfirmShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors    []string `json:"errors"`
			Status    string   `json:"status"`
			Timestamp string   `json:"timestamp"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseEstimateShippingCostForShipmentResponse parses an HTTP response from a EstimateShippingCostForShipmentWithResponse call
func ParseEstimateShippingCostForShipmentResponse(rsp *http.Response) (*EstimateShippingCostForShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EstimateShippingCostForShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRefreshLabelResponse parses an HTTP response from a RefreshLabelWithResponse call
func ParseRefreshLabelResponse(rsp *http.Response) (*RefreshLabelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Awb *string `json:"awb,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateParcelsResponse parses an HTTP response from a UpdateParcelsWithResponse call
func ParseUpdateParcelsResponse(rsp *http.Response) (*UpdateParcelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateParcelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadyToShipResponse parses an HTTP response from a ReadyToShipWithResponse call
func ParseReadyToShipResponse(rsp *http.Response) (*ReadyToShipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadyToShipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReassignShipmentResponse parses an HTTP response from a ReassignShipmentWithResponse call
func ParseReassignShipmentResponse(rsp *http.Response) (*ReassignShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReassignShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReprocessShipmentResponse parses an HTTP response from a ReprocessShipmentWithResponse call
func ParseReprocessShipmentResponse(rsp *http.Response) (*ReprocessShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReprocessShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCollectionScheduleResponse parses an HTTP response from a UpdateCollectionScheduleWithResponse call
func ParseUpdateCollectionScheduleResponse(rsp *http.Response) (*UpdateCollectionScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCollectionScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDeliveryPromiseResponse parses an HTTP response from a UpdateDeliveryPromiseWithResponse call
func ParseUpdateDeliveryPromiseResponse(rsp *http.Response) (*UpdateDeliveryPromiseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDeliveryPromiseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDeliveryScheduleResponse parses an HTTP response from a UpdateDeliveryScheduleWithResponse call
func ParseUpdateDeliveryScheduleResponse(rsp *http.Response) (*UpdateDeliveryScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDeliveryScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateStatusResponse parses an HTTP response from a UpdateStatusWithResponse call
func ParseUpdateStatusResponse(rsp *http.Response) (*UpdateStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors    *[]string `json:"errors,omitempty"`
			Status    *string   `json:"status,omitempty"`
			Timestamp *string   `json:"timestamp,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}
